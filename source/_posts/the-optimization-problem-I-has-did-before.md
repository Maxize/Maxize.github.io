---
title: 那些年我做过一些关于游戏的性能优化
date: 2017-09-01 12:20:04
categories: Skills
description: 为什么我们的游戏只有 20 帧，别人的游戏 60 帧，而且这么流畅，耗电量少，手机不烫，你看看，你要怎么解决？明天给我方案！
tags: [optimization, performance, 性能优化]
---

## 前言

去年我觉得自己最大的成长就是从做出一个游戏到做好一个游戏的转变。也是因为这个，重新认识到做好一款游戏是不容易的。

性能优化是一个老生常谈的问题，而自己刚好做了这么一些事，就来写一篇博客总结一下，给之前的辛苦劳动画上一个完美的句号。

一开始接触性能优化我也是一头雾水，因为原来就没有接触过，或者有一些方法是前人已经总结的，你只需要这么办就好了，但到你这里，其实是一知半解的，所以做起来就蹑手蹑脚的。

### 经历的阶段

回过来总结过去的经历，分成三个阶段。

1. 死马当活马医
2. 开始会开处方了
3. 可以传教了

一开始就是，有什么方法好使就用，有什么可以尝试就试，也没有弄明白这样做有意义么？先干了再说。

后面就是，开始会规划，采用数据来支撑自己的优化，没有达到结果就要反思和重新寻找有效的措施。

慢慢积累一些经验之后，除了科普给组内还可以到外面随便说说了，这事咱确实做过了，不怂！

再说一个结论，也是我的感悟吧。不到万不得已，没必要优化代码。

原因是，这一步应该是最后进行的，而且效率是最低的，还有就是在目前的手机运行环境下，代码性能的那点优化没有多大作用，只是心理安慰而已。

## 目标

### 概述

其实一开始并没有制定什么目标，只有一个比较模糊的想法，那就是做一款精品。对比竞品「天天德州」，也发现腾讯在这一块质量把控是有一个完整的流程，后面我们也是参照 [WeTest](http://wetest.qq.com/) ，借助 [GT](https://github.com/Tencent/GT) 采集游戏的基本数据，然后对我们自己的游戏进行评估和总结。

从结果上来看，单纯数据，我们游戏也不会太差，但是整体的玩牌流畅度体验不佳，在一些地方会让玩家等很久，而这些是数据不能反映出来的。

我们第一次采集到的数据，FPS 37+， CPU 占用 17.45% - 23.97%， 内存在 59-166MB，流量消耗 10MB。

参照 WeTest 发布的 [中国移动游戏质量白皮书](http://wetest.qq.com/whitepaper/2016) 提供的关于棋牌类游戏的几个指标，我们游戏还是有不少距离的，但不至于经常有卡顿。

白皮书中低端机（未列出）的几个数据： FPS 31.83， PSS 内存峰值 125.3MB， CPU 16.07%。

后面我们在数据指标中加入其他的考量标准，比如低帧率，这个可以更好的反映一款游戏的流畅度；而对于内存和 CPU 没有更高的要求；游戏启动时间（冷启动和热启动），这个是玩家在点击 ICON 到进入到关键位置的时间；场景切换时间，这个没什么好讲的，主要考量是进入到房间玩牌的时间。

通过上面几个来反映我们游戏的质量是不是够硬，当然现在依然在继续做着。

后记：关于一些数据反映出来而觉得需要优化的时候，会因为引擎本身的性能而导致无法进行，这一块在自研引擎上体现的更明显，所以在选择引擎进行开发的时候最好能对引擎适用于开发什么游戏，能达到什么样的性能要有一个清楚的认识。

### 性能优化方向

汇总一下，考虑性能优化关心的几个方向：

1. 平均帧率
2. 流畅性（低帧率）
3. 互动延迟
4. 等待时间
5. 内存用量
6. 游戏体积
7. 网络流量
8. 耗电量

## 实施

通过采集数据然后就发现了诸多问题，主要表现集中在，启动游戏慢（10s），弹框卡顿，玩牌不流畅，场景切换不流畅，滑动列表卡顿，动画不流畅，网络请求引起的卡顿，Loading 卡顿，耗电量大等等，而这些问题汇总起来矛头直指 IO，代码和资源过于臃肿，有一些实现确实过于耗费性能等等。

而需要在 30 多万行代码中把这些东西都处理好还是有点头疼的，所以我们需要制定优化标准和措施。

有一条标准就是，**在保证目标的前提下（相关数据指标），优化都是相对的，一旦优化过了势必会影响其他的模块。**

### 选择策略

我们在过程中总结出来的有这么几条策略：

1. 在保证内存不超标的情况下，可以尽可能缓存相关纹理和对象，必要的时候加入对象池
2. 不要一次性加载所有的资源，可以按帧加载，异步加载
3. 文本纹理其实很耗性能
4. 单线程解决不了的问题，考虑多线程
5. 纹理格式选择，RGBA4444 > RGB565 > RGBA8888
6. 批量渲染是个好东西
7. 要清楚的明白实用的引擎的瓶颈在哪里

### 关键指标

再来看看几个指标跟什么关系最大。

* FPS
    - 除去 IO 的影响， DrawCall 是最主要的因素，通俗一点理解，当前帧需要绘制的东西有多少
* 流畅性
    - 理想状态是在资源准备完毕的情况，需要渲染的东西不多，自然就流畅了，当然跟引擎底层的渲染机制也有关系
* 互动延迟
    - 这一块跟网络也有关系，有一些游戏不管你网络如何，该有的反馈先给了，后面再做数据同步就好了，那么这种的延迟就会低，但有一些是只有等到网络返回数据再展示页面，在网络好的时候，表现不明显，但是网络差的时候就恶劣了。
    - 显示策略也有关系，比如我们之前遇到的弹框，有缓存的比没缓存的快，有分离 UI 视图的比没有分离的快，你要清楚知道用户点击这个按钮之后最想看到什么，优先提供就好了
* 等待时间
    - 这一个跟游戏整体的文件数量和文件大小有关，理论上加载大图会比加载散图快
    - 网络延迟也有关系
* 内存
    - 游戏中占用内存最大的部分还是纹理资源（图片，文本图片），代码占用反而不多，当然内存泄漏的问题要持续关注
* 游戏包体积
    - 主要跟图片，音频，视频，第三方库和 SDK 有关
* 网络流量
    - 跟游戏的数据交互量有关了，其次配置信息能提前下载，下载的图片，能缓存就缓存起来
* 耗电量
    - 耗电量会大，CPU 就高了，而 CPU 高跟计算量和单位时间运行处理的数据量有关

好了，了解了之后我们就开始讲一下我们做过的一些优化行为吧。

## 我们做了什么？

### 图片处理

* 去重

去重的意义在于减少重复的图片对拼图造成一定的影响，也可以减少一定的包体积。

为什么有这种情况？

因为在开发过程中不同功能反复用到同一张图片而设计提供的时候多给了，客户端没注意从而引入了。

一开始要解决这个问题，头大，人工处理会累死的，整个过程将是枯燥无味的，也是通过这个，我慢慢采用 Python 来处理类似的问题，后面发现确实挺有用的。

讲一下解决思路：

首先，找出图片目录下的所有图片，并用 list 存储所有的图片路径，然后计算出图片大小，相同的话再计算 md5 值，如果两个都相同，就认为图片相同了；
其次，删除掉相同的图片，保留一张，我其实是把他们移到其他目录，并留下操作日志
最后，通过遍历所有的代码和布局文件进行替换，完成整个过程。
代码后续再补充吧。

* 去除无用的图片

这个主要解决跟上面的情况类似，减少包体积的。

解决思路：

首先，建立图片路径的索引，图片目录的比较简单，代码和布局文件中的采用取并集去重
其次，对两个大索引取差集再取交集就能找到最后哪些图片没有被使用了
最后，肯定有误杀，还要把误杀的救回来，这一块通过人工检索，把误删的通过字符串匹配救回来

* 拼图

这一块的效果是很显著的，提高的读取图片的速度，对渲染效率也有一定的提升。拼图的规则首要规则是，同个场景或者布局的图片尽量拼到一张图片里面，次要规则，尽量消灭散图，因为提升 IO 的效果真的很显著。

除了对图片进行拼图，其实要更好的效果，需要对布局也进行调整，效果会更佳。因为引擎在渲染的时候，如果想对一些节点进行打包渲染，那么最好的状态的，要打包渲染的资源在一张图片里面（同个纹理），节点是连续的（减少纹理切换的开销），所以我们按照这个进行调整，实际上这一块是很烦的，一动了之后代码也要修改。

看实际的时间，可以考虑先拼图再改布局

* 压缩图片

压缩图片是一个有损的过程，一般如果不改 RGBA 的话，只是减少了图片本身的大小而已，改了 RGBA 才会影响 GPU 内存大小，加载图片到内存只跟图片的宽高有关。这边采用的是 [TinyPng](https://tinypng.com/) ，国际惯例，还是采用脚本自动批量压缩，记得准备几个 AppKey ，一个 key 一个月最多只能压缩 500 张图片。

另一条压缩图片的操作效果也是立竿见影的，我们设计分辨率是 1280x720，（1G 内存 CPU 双核）加载一张背景图片的时间是 120ms 左右，如果把图片缩小到 960x640 ，加载时间可以减少一半左右，大小减少 1/3 ，显示效果无异。

天天德州对背景也是单独处理的，不过他是采用把 1280x720 的背景通过裁剪拼图改成 1024x1024，这一个是考虑一些低端显卡，在处理的时候把宽高扩展到 2 的指数幂，那么用 1024 比较理想。

我们还做了另一件事，我感觉是提升更明显的。对一些左右对称的背景，只保留一半，剩下的通过镜像生成，再合并成一张。是不是有点流氓，不过使用条件也比较苛刻，不过我们项目刚好有好些大背景就是这样的，所以很受用。

### 提高渲染效率

* 减少节点数

有些布局确实就是采用几个节点来做一个节点也能做的事情，当然也有一定的原因在里面的，但从过去来看，影响最大的就是我们喜欢把背景和其他其实可以合并成一个节点的，分成两个来使用，使用高通的 AdrenoPrifiler 查看一下渲染效率就可以很清楚的看出来了，百分之七八十的时间就被他们用了，其他一些小图片只有一点点开销而已。为什么要分成两个，最大的原因是，在图片拉伸的时候，上面的这个节点一般不采用拉伸，跟背景一起拉伸的话容易变形。

我们在一些布局中，使用了空白图片来消费一些事件，这些可以采用使用空节点替换

其他一些是跟业务有关的了，减少节点数还有一个方式就是动态合并节点，即在布局中用的几个，如果是静态的，那么可以采用动态合并的方式处理一下。但要考虑一下图片的设计宽高和合并生成的图片的宽高，在高分辨率的手机上，内存占用会大很多。

* 拉伸图片和合并图片

一些图片其实可以采用拉伸的，但设计提供的却是一张整图，这个其实是很浪费的，采用拉伸的方式，只是有一点 CPU 的开销外，总体上利大于弊的，小体积，加载快，你怎么能不心动呢？

合并图片这一块，在按钮和按钮上的文本表现尤著，如果不考虑多语言版本，其实合并起来会更好，就算多语言也可以通过一定 **命名规范** 和 **设计辛苦点，统一输出** 一下，可以减少一半的开销。**文本也是图片。**

* 批量渲染

批量渲染的意义在于统一打包一次输出到显卡渲染，可以提高渲染效率。因为在很多时候，GPU 的工作量是不饱和的，一次性多提交点东西给 GPU 是很有必要的，不然 CPU 累死累活， GPU 却在打酱油。

批量渲染的好处是很明显的，渲染效率可以提高，在一定程度上可以减少包体积。比如我们把 52 张扑克牌采用这种方式渲染，效率更高，同时图片大小减少了 80%。

在做一些粒子效果，或者同时有多个筹码要渲染的时候，表现也是很明显的。

### 启动缓慢

* App 启动的三个阶段
    * 点击 ICON 到进入游戏的过程（这一块基本上控制不到）
    * 进入游戏入口到准备资源完毕
        - 这部分一般包括两个阶段（启动 Lua VM 之前之后），这一块最主要的就是初始化一些对象，当然还有一些 SDK 的初始化（考虑开线程处理），之后会有一些系统数据要准备传给 Lua 端
    * 显示界面
        - **加载 Lua 文件**，我们项目采用的是散文件一个个加载的，为了解决这个我还把 require 重写并统计出加载比较费时（20ms）的文件，我以为我们项目一开始加载的应该不会太多，结果发现 1 千多个文件都加载了，这想快也快不起来呀，解决的话，启动的时候只加载必要的，后面在空闲的时候再把其他一些满满加载进来，当然一些没必要加载的可以等到用的时候再加载
        - 另一种解决思路是，使用 zip ，把所有的文件打成一个包，这样加载可以很快，后面重新再 require 的时间开销也很快
        - **加载音频文件**，这一部分的开销，也挺大的，而且一般也会预加载。
        - **加载布局文件和场景的图片**，分帧加载，分离视图完美解决
* 切换后台再回来

原来我们这一块会重新加载一遍纹理，所以回来会黑屏几秒钟，后面我们不清空纹理的方式加快了回来的时间

* 应用内业务的启动相关

1. 打开一个弹框
2. 打开一个场景
3. 打开 XX 

这里说一下比较彻底的解决方案，也是理想的解决方案，**统一样式，提前加载好**。这种是最彻底的，也是最有效的。

当然在项目已经成型的情况下，很难，很难，那么我们的统一做法是，**分离视图，分帧加载**，这种也是比较有效的方式，先展示背景，剩下的界面分几帧加载完，这种方式玩家可以最快看到界面，后面刷一下满满出来，会比玩家等个 1-2s 然后全部看到会好很多，当然再补充一个动画上去，就可以很好的掩盖这个效果了。

如果遇到一些可以缓存起来的公共控件，在**移除的时候缓存起来**，也可以加快启动。

### 统一管理弹框

其实这个应该是一开始就要设计好的，但当时我们做这个的时候只设计了一个关于弹框的基类，而管理类却没有，在设计初期，也没有那么大的需求，如果你一个游戏只有几个弹框，那么太复杂确实意义不大，但项目慢慢做大，久了之后，一百来个弹框的话，就很有必要管理了。

先说我们存在的问题，弹框都是在各个场景自行加入的，从使用上来讲，自己管理构造和析构，缓存，动画等等，容易出现析构遗漏，导致内存泄漏，不同的弹框在实现差不多的情况下，有不同的实现，包括一些动画也会写好几份，没有一个统一的行为；资源管理也混乱，调用关系不明确等等。

优化这个的主要目的，一方面方便管理，另一方面也是在统一规范之后对弹框有一个合理的要求。我们的要求是：

1. 第一次打开和缓存打开的时间消耗要接近不能超过 30ms
2. 使用者不需要自己管理弹框的析构，通过构建的时候传入参数
3. 加入高斯模糊背景（可以在弹框出现的时候隐藏底下的场景，减少绘制，减轻压力）
4. 取消空白节点消费事件
5. 最好都能拼图处理
6. 一些效果用 shader 替换

弹框管理的一些要求：

1. 调用者只需指定一个弹框 ID 就能在任何地方创建一个弹框
2. 不需要管理动画（弹出，收起）
3. 支持预读缓存
4. 不需要管删除和释放（通过参数指定）
5. 支持多种类型（Toast, AlertDialog, Tips），这个后面没有实现，也不是必要的

通过上面的一个操作之后，我们可以更好的保证弹框的显示效率，也能方便开发友好的管理。

### ListView 优化

把这一块也拿出来讲着实是因为我们目前的 ListView 流畅度饱受吐槽。

最烂的设计，每个 cell 都是动态创建的，无限在后面追加。

稍微合理的设计，加入缓存，加载的时候采用延迟加载，一次加载几个，这种体验会比上面的好几个 level，但对内存的占用略大。

**我觉得合理的设计，采用复用 cell 的形式，控制每个 cell 的内容，优先显示背景，带 cell 稳定下来之后再显示全部内容，如果有文本考虑缓存文本，通过数据来驱动，几个 cell 创建速度快，滑动也流畅，堪称 ListView 届的楷模。**

如果你不清楚如何设计一个滑动流畅的 ListView 这个思路可以借鉴一下。

讲到 ListView 就不得不顺便提一下 ScrollerView 一般都会继承自它，但 ScrollerView 存在的一个问题也是跟 ListView 类似，我们遇到比较多的除了这个，还有一开始创建的时候耗时略大的问题，这个后面我们采用分帧加载的形式缓和了，并在当前也加载完毕之后开始预读一些 cell ，但还是不要一个 ScrollerView 加载过多项，内存占用会随着项越多越大。

### 数据请求优化

提起这一块，能做的操作还真的不多，而我们遇到的问题也是其他项目经常遇到的。

优化的做法，我总结一下：

1. 更快的请求
2. 更少的数据传输
3. 尽量少的请求

我们做过一个统计，每个 Http 请求的耗时大概是 15ms ，刚好一帧的时间，但在使用的时候不会是只有一个 Http 请求，掉帧就成为必然了，一个网络请求在网络稳定的情况下回来差不多要 120ms ，相对于 Socket 的返回确实长了一点，而且数据量重复多，但数据量可以稍微大点，如果有条件或者对延迟有要求，还是采用 Socket 进行数据通信。

一般现在的 Http 请求都会加密，我们也不例外，通过分析发现加密耗时大概在 8ms 左右，通过重构优化减少了一半，只要 4ms ，想不明白的是再调用底层库处理的时候耗时 7ms，我认为这个过程应该是基本不耗时的，但分析发现，他的时间一部分在处理堆栈的时候，还有一部分时间是创建一个 Http 请求上，于是在这里引入多线程处理，数据传过来接下来你就等回调好了，这边帮你搞定。这样总体下来，把一个请求时间减少到 5ms ，这样原来一个请求的时间可以连续发起 3 个了。意外收获是顺便解决了一个内存泄漏的问题，处理完回调之后数据都留在内存里面而没有删除，虽然有的只有 1-2k ，但有的却有 50-60k ，积少成多呀。

请求方面的效率解决了，如何减少数据量也是需要考虑的问题，时刻想着用户是在一个网络带宽小的环境，用户的流量都是要付费的，那么减少一点是一点， [Gzip](https://zh.wikipedia.org/wiki/Gzip) 是一个比较通用的方式，在成熟的 Http 库下都支持，而且效率还可以， CPU 的占用还是比较小的，数据传输量可以减少 60% 以上，是不是百利无一害？

最好的情况是减少 Http 请求，是的，我们可以。这里减少有两层含义：

1. 客户端通过缓存数据减少请求
2. 能一个请求搞定的就不要用多个请求处理

讲一个我跟同事讨论的，不过要求比较高，不好实现，需要改底层。合并多个 Http 请求，用一个请求的消耗，完成几个请求，是不是听起来就很高大上。我曾经在 Skynet 尝试封装和解析过一个 Http 请求，底层也是采用 Socket 方式来处理的，那么这种封装多个请求理论上是可行的。有兴趣可以尝试一下。

当然有条件的话，还是用 **长连接** 的方式来请求网络通信，速度更快，数据利用率更高。

### 优化动画

动画相关的优化，我觉得最大的成就就是把内存和显存都减少到原来的 1/3 ，当然还有其他的优化操作。

我们这边动画最突出的问题就是内存占用大，不流畅，动画单一，做动画比较耗时且容易出错。

表现就是，多使用帧动画，播放动画的时候有一些其他的操作，主要是 IO 操作，纯代码写的动画，过程繁琐，有些用法不规范导致一些泄漏。

我们优化的做法：

1. 采用缓动，加入贝塞尔曲线
2. 使用工具将设计的 Swf 动画直接转换成可以读取的格式（BabeSwf/Gaf）
3. 动画使用到的资源提前加载
4. 配合设计调整动画效果，在允许的范围内减少动画尺寸和减少帧数

这一块的操作比较繁琐，需要反复测试和同设计反复商榷。

### 内存泄漏检测

内存也是游戏关注比较多的问题，特别是前几年设备的内存没那么大的时候，对内存的要求是斤斤计较，但现在时代进步了，对他的要求没有原来那么高了，但如果要适配更多的机型还是要注意一下，我们对这一块的要求没那么高，于是该用的就用，别客气。

内存泄漏一般来讲都是对于没有垃圾回收机制的语言而讲的，但也不是说他们没有。

关于 Lua 的内存泄漏，一般指 **已经没有被使用了，但外部依然还有引用存在的对象**。 特别需要提防全局表 `_G`，经常一不小心就把一个 `local` 的 变量变成全局的了。关于这个云风大大有一个工具可以借鉴一下，[snapshot](https://blog.codingnow.com/2012/12/lua_snapshot.html)，不过从我们项目上看效果还是不佳，所以你最好还是了解一下 [Lua内存泄露检测原理](http://blog.csdn.net/shimazhuge/article/details/43794347)，然后自己写因地制宜的工具。

而检测是否有内存泄漏比较好的 `Tips` 就是开启没帧垃圾回收，看 Lua 内存的总体有没有增长，有的话你就需要注意了。 

```lua
collectgarbage("collect") -- 为了有干净的环境，先把可以收集的垃圾收集了  
collectgarbage()
```

还有另一个操作就是在代码中设置合理的步长和垃圾回收的时机，这一块的可以详细看一下 Lua 的垃圾回收 [API](https://www.lua.org/manual/5.1/manual.html)。

```lua
collectgarbage("setpause", 150)
collectgarbage("setstepmul", 5000)
```

既然 Lua 内存泄漏的情况比较少，那么还有内存泄漏，那就证明是其他地方出现的咯。特别是像我们游戏采用 C++ + Lua 的，一不小心就会出现一些 C++ 的内存没有释放干净。之前我们就有找到一些，申请了内存却没有释放掉的，虽然每次只有 4kb ，但也是泄漏。这一块的话，推荐在 Mac 下使用 Instruments 工具来检测 [iOS/OS X内存管理(二)：借助工具解决内存问题](http://www.jianshu.com/p/09c5141d4531) ，感觉更友好一点，还有就是通过 **静态分析，人工缩小范围** 的方式，多种方式并用。

Android 下的话可以引入 [LeakCanary](https://github.com/square/leakcanary) 库辅助，除了这个就是使用 `dumpsys` 命令了。Android 下的话可以关注一下 Webview 的内存泄漏问题，我们项目有一大部分内存泄漏也是因为它，这一块请自行 Google 之。

内存的几个大类，Lua 内存， Native 内存（ 图片／C++ ），堆内存，纹理内存。

纹理内存也是一个需要关注的地方，有一些确实是你要缓存起来的，但有一些也是应该释放掉的，你要持续关注咯。

关于内存泄漏这一块的，我也还在持续关注和学习中，总感觉还是没有 Get 到一个要领，解决起来特别头疼，如果你有很好的方式欢迎告诉我。

## 总结

这篇文章断断续续写了几天，回过头来看，确实不好写，也写的有点乱，旨在把我所了解的和理解的说出来。虽然大部分是汇总一下过去做过的优化，但是涉及到的一些细节，还是需要去回顾一下，才能梳理清楚，通过一篇文章来整理陈述一下，也算是加深了印象，也希望要做性能优化的你们有所帮助，而我们项目在经历这些操作之后，性能确实提升了一个大台阶，这一点还是值得欣慰的。

如果你也有良计，欢迎互相探讨，学习进步。
