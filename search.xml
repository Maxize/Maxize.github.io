<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用 sigh 重签名 IPA]]></title>
    <url>%2F2018%2F02%2F06%2Fhow-to-resign-the-ipa%2F</url>
    <content type="text"><![CDATA[安装 Homebrew在终端先后执行下面2命令行安装，等待进度完毕 12xcode-select --install ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 ruby在终端执行下面命令安装 ruby，等待进度完毕（输完密码可能在较短时间无反应） 1brew install ruby 安装 sigh 脚本执行下面安装命令 1sudo gem install sigh 若出现以下报错 123ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rougify 则安装命令修改为 1sudo gem install -n /usr/local/bin sigh 使用 sigh 脚本开始重新签名 在终端输入 sigh resign，回车 把要签名的 ipa 文件（路径、包名不要有中文，例如可以把小草改为 1.ipa）拖到窗口上，回车 填写用来签名的证书名（钥匙串中的完整名字），回车 把项目的配置文件 .mobileprovision 文件拖到窗口上，回车 好了，resign 脚本会自动更改 bundel id，签名并重新打包。 完成后提示 Successfully signed ，新生成的包会替换原有文件 进行安装由于 iTunes 在 12.7 取消安装应用，所以本人使用 iMazing 安装的，也挺方便的。 引用 在未越狱IOS设备上利用自带“终端”工具重签名安装草榴社区官方客户端 MacOS 使用“终端”对 ipa 重签名 Homebrew 官网 Sigh 脚本 github 地址 最简单的重签名应用的方法 iOS 的 ipa 重签名 Cannot install cocoa pods after uninstalling, results in error mac 用终端对 ipa 包重新签名 - 胡东东博客 Mac OS下包管理器 Homebrew 的安装与使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>resign</tag>
        <tag>IPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的 Linux 命令（自己留档备用）]]></title>
    <url>%2F2017%2F12%2F19%2Fusefull-bash-set%2F</url>
    <content type="text"><![CDATA[背景Linux/Macos 下使用命令行的机会还是很多的，但是有一些命令只有经常用才会记得，不用的话，过一阵子就会忘记，那么收录到自己的文章里面就很有必要了。 本着「备份索引」的目的，内容只会加入自己涉猎过的，其他未涵盖的可以多多讨论，一起认识和储备下来。 内容查找当前目录下是否包含关键字目录1find . -type d -print | grep "custom" 指定路径下查找某个文件1find [path] -type f -print | grep "custom" 指定路径下查找某类文件1find [path] -name "*.jpg" 总结好记性不如烂笔头，自己的东西终究是最趁手的。 一个「有个性的」程序猿总是在重复制造轮子，理由是我也要成长，也许是因为我还没有到不需要重复造轮子的境界吧。]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
        <tag>Bash</tag>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏分享的问题]]></title>
    <url>%2F2017%2F12%2F01%2Fshare-for-mobile-game%2F</url>
    <content type="text"><![CDATA[背景本来不想记录的，让自己想铁下心来写这篇 Blog 的原因是前阵子在接入 FB 分享的时候，明明已经处理好了，可是出了问题，想去找一下 FB 的分享调试器的时候，居然绕了一大圈才找到，这样才萌生了念头。 废话不多说，本 Blog 我想分为以下几方面去介绍。 一些常见平台分享功能的限制和要求 我接入 SDK 的惯用伎俩 我接入过的一些平台踩过的坑 正文常见平台分享的要求我们都知道不同平台，分享功能的要求是不一样的，每个平台都会有一些限制，个中要求只有接过了才能明白，所以如果有人列一个大纲，帮你介绍一下这个东西的话，那是不是就会很爽很开心。 目前已经有不少提供第三方 SDK 帮我们聚合分享功能了，但有时候我们还是需要自己操刀接入一些，有这么一个东西还是好处大大的。 之前浏览网页的时候发现了这么一个网页，后面也没有记录下来，然后花了点时间把他找回来，特此奉献一下。 不同平台分享内容的详细说明 其实我害怕哪一天这个网址会失效，有想法想把这篇自己再重新用 markdown 写一下，留下来备份。 由于内容过多，有兴趣的可以自己翻阅这个地址查看，我就不在这里展示了。 SDK 你是怎么接的 查看官方文档和官方 Demo(最喜欢有 GitHub 的 SDK) 遇到问题了，确认文档已经都看好了 有技术支持，可以直接咨询，不然只能搜索引擎走起 项目中接入的形式 使用 AnySDK or 其他聚合 SDK 如果有 C++ 版可以优先考虑接 直接原生接入（推荐，省心，跟原生一样处理就好了） 我踩的坑楼主已经接过的 SDK 有： 国内的 SDK： 新浪微博 微信（登录与支付） 短代 银联支付 友盟 …… 国外的 SDK： Facebook BluePay Mol 支付 E2Pay TalkingData fortumo 支付 …… 其他想不起来了，哈哈。 貌似扯的有点远了，要回到分享功能上了。 Facebook 分享的坑楼主最近在处理 FB 分享的时候遇到的问题以及接入 FB 可以使用的工具 官方提供的工具官方有一个网址，提供了我们在接入 SDK 可以使用的工具，看这里工具和支持 主要的工具有： 图谱 API 探索工具 分享调试器 「图谱 API 探索工具」是我之前在客户端使用他来发送分享功能的，因为可以自定义内容，而且也可以方便测试，但他是需要获取玩家的 publish_actions 权限的，而且在调用的时候就要提前获取。 「分享调试器」是 Facebook 通过爬虫抓取你的分享地址来展示，可以图文，也可以是视频，但是对应的地址需要提供类似以下标签。 123456789101112&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" xmlns:fb="http://www.facebook.com/2008/fbml"&gt;&lt;head&gt;&lt;title&gt;The Rock (1996)&lt;/title&gt; &lt;meta property="og:title" content="The Rock"/&gt; &lt;meta property="og:type" content="movie"/&gt; &lt;meta property="og:url" content="http://www.imdb.com/title/tt0117500/"/&gt; &lt;meta property="og:image" content="http://ia.media-imdb.com/rock.jpg"/&gt; &lt;meta property="og:site_name" content="IMDb"/&gt; &lt;meta property="fb:admins" content="USER_ID"/&gt; &lt;meta property="og:description" content="A group of U.S. Marines, under command of a renegade general, take over Alcatraz and threaten San Francisco Bay with biological weapons."/&gt; ... &lt;/head&gt; ... &lt;/html&gt; 官方给的一个指导建议： 最佳实践 大家可以优先看一下这个指导。 分享有哪些方式从最佳实践那里我们可以看到，目前支持的方式有： 分享对话框 （类似微信分享到朋友圈） 分享到 Message （类似微信分享给好友） 分享 “关注” 按钮 （跳转到粉丝页） 分享 “like” 按钮 通过分享 API 分享 因为 Facebook 有爬虫可以帮你抓取页面，所以你可以自定义你的分享链接地址，而分享的链接可以指定跳转到对应的游戏，这一点可以更容易的导量到你的应用，让分享的意义放大化。 总结就是，使用前三种分享，是一个免费的带量行为，值得我们花时间去完善它。 说到这里，其实就是可以通过 FB 接口获取好友的信息，然后邀请好友玩游戏，如果有 Web 版本的游戏体验会更好，不然就是跳转到应用商店或者启动应用。 有一些官方隐藏的坑FB 比较坑爹的地方是 API 会随着版本发布经常变动，而且时不时还会抽风。 笔者遇到的一个情况就是，之前明明分享出去的地址是可以抓取到图片的，然后突然之间就不可以了，表现就是分享时设备也不显示了，分享出去之后也没有。当然这个是有一定要求的，比如说图片的尺寸要求（1200 * 640 以上），分享的链接需要指定参数。 后面没有改动，分享出去的时候能看到图片了，但是分享时还是看不到图片。 相关的要求可以参考这个（抓取不到图片）： 图片尺寸 0 x 0 ~ 199 x 199 = 会抓不到图 200 x 200 ~ 599 x 314 = 会抓到小图 600 x 315 ~ 1500 x 1500 = 会抓到大图 1501 x 1501 ~ 以上 = 会抓到小图 图片大小不可超过 5MB 使用 og:image:width 跟 og:image:height 来直接指定图片宽高 参考：Facebook 文章分享的預覽圖片，顯示為寬版大圖的設定方式 - og:image 的 image size 條件 查看更多 当然还有三个点是血的教训，也要提一下。 对同个好友不要邀请过多次 一天不要发送太多的帖子 登录账号 IP 不要经常变动 这几点都会导致 FB 封账号，再严重一点 FB 会觉得你的应用分享过于频繁，会把你的应用也封了，而申诉都非常麻烦，尽量不要尝试。 总结这篇博文断断续续写了一两周，感觉还是没有把都要说的说明白，后续看看再来补充好了。 如果对你有帮助，那么就最好不过了。]]></content>
      <categories>
        <category>业务功能</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Share</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发向导]]></title>
    <url>%2F2017%2F11%2F23%2Fios-guide-tips%2F</url>
    <content type="text"><![CDATA[背景没有实际躺过坑，就无法知道深浅，过去一直以为就算其他什么也不懂，但只要查找一下资料，还是可以很快入门的，但实际操作起来，别人一两小时可以搞定的东西，你或许还是要花费 1-2 天才能正确实施，当然，我把这个划分到学习成本里面吧，慢慢积累和收录一些过程中的问题，我相信，以后也可以更快的开发。 更新日志 2017-11-23 init this news 2017-12-20 新增 「关于 OpenUDID 的使用」 2017-12-21 新增 「DSYMs 的作用？」、「URL Schemes 使用详解」 2017-12-25 新增 「证书相关」、「URL Schemes 使用问题」和「-[__NSCFString stringValue]: unrecognized selector sent to instance 0x174429f40」 2017-12-26 新增 「iOS 下实现类似 Java 反射的实现」和 「iOS 下支持的布尔类型」 三两问题如何入门 iOS 概述 60 分钟就能入门，你信不信，反正我不信，那你看看怎么样？iOS开发60分钟入门 开发语言 Objective-C 工欲善必先利其器，连用什么开发语言都不懂的话，那不是很悲哀，正好之前浏览过一个网站，如何在 X minutes 下学习 Y，刚好拿来用用，也是英文不好，但也只能硬着头皮啃。这里传送： Objective-c 开发工具 Xcode 证书相关关于证书的相关问题可以查看博客下的单独文章： iOS 开发者证书总结 in-house iOS icon 尺寸要求以前只知道 iOS 发布的时候，需要给一套 icon，但其实不清楚有哪一些，以前注意点是什么？我觉得这样的问题不止我有，其他人肯定也有，所以一些聚合性的网站就帮你收集了相关的知识点，好人呀。 看看官方文档，官方永远是权威的，不要质疑! 作为懒人肯定是想偷懒的，所以如何快速输出对应尺寸的图片也是要知道的。 首推图标工场，一键生成你需要的所有尺寸，简单粗暴。 PhotoShop 通过脚本生成对应尺寸，将下面的内容保存为 .jxs ，通过 Photoshop 运行即可，定制性更强，以后可以自己动手。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#target photoshopapp.bringToFront();var sizeList =[ &#123;&quot;name&quot;: &quot;iTunesArtwork&quot;, &quot;size&quot;:512&#125;, &#123;&quot;name&quot;: &quot;iTunesArtwork@2x&quot;, &quot;size&quot;:1024&#125;, &#123;&quot;name&quot;: &quot;Icon&quot;, &quot;size&quot;:57&#125;, &#123;&quot;name&quot;: &quot;Icon@2x&quot;, &quot;size&quot;:114&#125;, &#123;&quot;name&quot;: &quot;Icon-@2x&quot;, &quot;size&quot;:114&#125;, &#123;&quot;name&quot;: &quot;Icon-40&quot;, &quot;size&quot;:40&#125;, &#123;&quot;name&quot;: &quot;Icon-72&quot;, &quot;size&quot;:72&#125;, &#123;&quot;name&quot;: &quot;Icon-72@2x&quot;, &quot;size&quot;:144&#125;, &#123;&quot;name&quot;: &quot;Icon-Small&quot;, &quot;size&quot;:29&#125;, &#123;&quot;name&quot;: &quot;Icon-Small@2x&quot;, &quot;size&quot;:58&#125;, &#123;&quot;name&quot;: &quot;Icon-Small-50&quot;, &quot;size&quot;:50&#125;, &#123;&quot;name&quot;: &quot;Icon-Small-50@2x&quot;, &quot;size&quot;:100&#125;, &#123;&quot;name&quot;: &quot;Icon-50&quot;, &quot;size&quot;:50&#125;, &#123;&quot;name&quot;: &quot;Icon-57&quot;, &quot;size&quot;:57&#125;, &#123;&quot;name&quot;: &quot;Icon-58&quot;, &quot;size&quot;:58&#125;, &#123;&quot;name&quot;: &quot;Icon-72&quot;, &quot;size&quot;:72&#125;, &#123;&quot;name&quot;: &quot;Icon-76&quot;, &quot;size&quot;:76&#125;, &#123;&quot;name&quot;: &quot;Icon-80&quot;, &quot;size&quot;:80&#125;, &#123;&quot;name&quot;: &quot;Icon-100&quot;, &quot;size&quot;:100&#125;, &#123;&quot;name&quot;: &quot;Icon-120&quot;, &quot;size&quot;:120&#125;, &#123;&quot;name&quot;: &quot;Icon-144&quot;, &quot;size&quot;:144&#125;, &#123;&quot;name&quot;: &quot;Icon-152&quot;, &quot;size&quot;:152&#125;, &#123;&quot;name&quot;: &quot;Icon-29&quot;, &quot;size&quot;:29&#125;, &#123;&quot;name&quot;: &quot;Icon-29@2x&quot;, &quot;size&quot;:58&#125;, &#123;&quot;name&quot;: &quot;Icon-29@3x&quot;, &quot;size&quot;:87&#125;, &#123;&quot;name&quot;: &quot;Icon-40@2x&quot;, &quot;size&quot;:80&#125;, &#123;&quot;name&quot;: &quot;Icon-40@3x&quot;, &quot;size&quot;:120&#125;, &#123;&quot;name&quot;: &quot;Icon-60@3x&quot;, &quot;size&quot;:180&#125;, &#123;&quot;name&quot;: &quot;Icon-60@2x&quot;, &quot;size&quot;:120&#125;, &#123;&quot;name&quot;: &quot;Icon-76&quot;, &quot;size&quot;:76&#125;, &#123;&quot;name&quot;: &quot;Icon-76@2x&quot;, &quot;size&quot;:152&#125;];//尺寸集合// var sizeList = [1024,512,192,180,152,144,128,120,114,100,96,87,80,76,75,72,66,60,58,57,50,48,44,40,36,32,29,16];//任意一个宽与高相等的图像，尺寸大于1024x1024像素。var fileRef = File.openDialog (&quot;请选择一个文件&quot;, &quot;*.png&quot;, false);//也可以在这里直接定义一个输出文件夹，Folder.selectDialog(&quot;然后选择一个输出文件夹&quot;);//我这里直接使用被选择图片的相同目录var outputFolder = fileRef.parent;//打开文件var activeDocument = app.open(fileRef);var destFolder = Folder.selectDialog( &quot;请选择一个输出的文件夹：&quot;);//运行批处理尺寸runNow();function runNow()&#123; if(activeDocument.height != activeDocument.width) &#123; alert(&quot;当前文件宽高尺寸不一致，脚本已中止。&quot;); return; &#125; // if(activeDocument.height &lt; 1024) // &#123; // alert(&quot;选择的原始图像尺寸必须大于等于1024x1024像素。&quot;); // return; // &#125; for(var i = 0; i &lt; sizeList.length; i ++) &#123; //重置图像尺寸 activeDocument.resizeImage(UnitValue(sizeList[i].size,&quot;px&quot;),UnitValue(sizeList[i].size,&quot;px&quot;),null,ResampleMethod.BICUBIC); //图像无论是放大还是缩小，都会变模糊，只是放大时模糊的快一些，缩小时模糊的慢一些 //所以这里复制一个图像进行锐化，可以让缩小后的图像清晰一点。 var duplicateLayer = activeDocument.activeLayer.duplicate(); activeDocument.activeLayer = duplicateLayer; duplicateLayer.applySharpen();//应用锐化 duplicateLayer.opacity = 40; activeDocument.flatten();//合并图层 var destFileName = destFolder + &quot;/&quot; + sizeList[i].name +&quot;.png&quot;; if (sizeList[i].name == &quot;iTunesArtwork&quot; || sizeList[i].name == &quot;iTunesArtwork@2x&quot;) destFileName = destFolder + &quot;/&quot; + sizeList[i].name; //保存的文件 var saveFile = new File(destFileName); //如果文件已经存在就先删除它 if (saveFile.exists) &#123; saveFile.remove(); &#125; //以 PNG 格式保存，带压缩 var pngSaveOptions = new ExportOptionsSaveForWeb(); pngSaveOptions.format = SaveDocumentType.PNG; pngSaveOptions.transparency = true; pngSaveOptions.includeProfile = false ; pngSaveOptions.interlaced = false ; pngSaveOptions.PNG8= false ; activeDocument.exportDocument(saveFile, ExportType.SAVEFORWEB, pngSaveOptions); activeDocument.activeHistoryState = activeDocument.historyStates[0];//还原到打开状态 &#125; activeDocument.close(SaveOptions.DONOTSAVECHANGES);//原始被打开的文件不保存，关闭源文件&#125; 如何在沙盒中读取和写入图片？ 保存图片 1234567891011// 首先,需要获取沙盒路径NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];// 拼接图片名为 &quot;currentImage.png&quot; 的路径NSString *imageFilePath = [path stringByAppendingPathComponent:@&quot;currentImage.png&quot;];// 获取网络请求中的 url 地址NSString *url = [dataDic objectForKey:@&quot;IndexUrl&quot;];NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:url]];// 转换为图片保存到以上的沙盒路径中UIImage * currentImage = [UIImage imageWithData:data]; // 其中参数 0.5 表示压缩比例，1 表示不压缩，数值越小压缩比例越大(到一定程度之后就没有效果)[UIImageJPEGRepresentation(currentImage, 0.5) writeToFile:imageFilePath atomically:YES]; 读取图片 12// 借助以上获取的沙盒路径读取图片NSString *imageFilePath = [path stringByAppendingPathComponent:@&quot;currentImage.png&quot;]; 如何合理的压缩图片？ 正常情况都很少需要压缩图片，但是在使用第三方 SDK 做分享的时候，人家对你的图片就有要求了，这个时候就需要对你的图片进行修饰一下了，如何最大程度保证图片的质量最快的压缩图片就是这里要讲的。 压缩图片的方法： 压缩质量 压缩尺寸 区别：压缩图片质量的优点在于，尽可能保留图片清晰度，图片不会明显模糊，缺点在于当图片质量低于一定程度时，继续压缩没有效果，所以不能确保压缩后的大小； 压缩图片尺寸可以使图片小于指定大小，但会使图片明显模糊(比压缩图片质量模糊)。 下面的代码就是围绕这两个来进行操作的，优先压缩质量，达不到要求在缩放图片尺寸，并使用二分法减少循环次数。 翠花，上代码： 1234567891011121314151617181920212223242526272829303132333435363738+ (UIImage *)compressImage:(UIImage *)image toByte:(NSUInteger)maxLength &#123; // Compress by quality CGFloat compression = 1; NSData *data = UIImageJPEGRepresentation(image, compression); if (data.length &lt; maxLength) return image; CGFloat max = 1; CGFloat min = 0; for (int i = 0; i &lt; 6; ++i) &#123; compression = (max + min) / 2; data = UIImageJPEGRepresentation(image, compression); if (data.length &lt; maxLength * 0.9) &#123; min = compression; &#125; else if (data.length &gt; maxLength) &#123; max = compression; &#125; else &#123; break; &#125; &#125; UIImage *resultImage = [UIImage imageWithData:data]; if (data.length &lt; maxLength) return resultImage; // Compress by size NSUInteger lastDataLength = 0; while (data.length &gt; maxLength &amp;&amp; data.length != lastDataLength) &#123; lastDataLength = data.length; CGFloat ratio = (CGFloat)maxLength / data.length; CGSize size = CGSizeMake((NSUInteger)(resultImage.size.width * sqrtf(ratio)), (NSUInteger)(resultImage.size.height * sqrtf(ratio))); // Use NSUInteger to prevent white blank UIGraphicsBeginImageContext(size); [resultImage drawInRect:CGRectMake(0, 0, size.width, size.height)]; resultImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); data = UIImageJPEGRepresentation(resultImage, compression); &#125; return resultImage;&#125; 引自： iOS 图片压缩方法 这里还有另外一位小伙写了一个相对比较全的方法，但在使用中遇到返回结果有异常的情况，还没有深入去剖析，不过思路跟上面一样，定制性更好，可以看看然后综合一下。看这里：UIImage 二分压缩图片 使用 target 解决一套代码多个 App 问题先上一些过程中找过的几个教程，后续再来做一下总结。 猿题库iOS客户端的技术细节（一）：使用多target来构建大量相似AppiOS - 创建大量相似App的另外一种选择Xcode:用于管理多个 target 配置的 XCConfig 文件 对比了几个，我发现目前我需要的还没有到他们使用的那么复杂，于是我只是简单的 duplicate 一下我的 target 然后就 over 了。 首先我梳理了目前项目中各个相似 App 的不同之处，汇总起来大概有这么一些。 包含了几个内容： icon 和 图片资源 国际化 证书 开发调试 配置文件 操作步骤： 在 TARGETS 下 选中 projectX（你自己的项目） 右键 Duplicate 然后选择 Duplicate(only) 复制一个新的 target 回车修改名字 同时修改 scheme 名字 scheme -&gt; manager scheme -&gt; 选中回车修改 删除默认的 projectX copy-Info.plist 文件 在项目文件路径下（runtime-src -&gt; proj.ios_mac -&gt; ios -&gt; verCustom）准备好当前版本的资源 新建新游戏名字目录 从其他项目下 copy 内容到当前目录 Assets.xcassets 是 icon 的集合，按照规格替换 icon i18n 多语言国际化，主要替换 display name 在 certificates 下准备好新的证书 Constant.plist 配置 API xx.entitlements 这个文件在修改权限的时候会生成（比如推送，支付），考虑到以后不同版本可能会不同，所以每个订制一个 icon.png 152*152 的 icon 文件 Info.plist 配置文件 在 Xcode 下导入刚才添加的文件（ add files to X ），用于后续配置 target 时使用 选中当前 target ，在 General 下选择新的 Info.plist 文件，修改 Identity 的相关信息 在 Info 下修改 Bundle Name, FacebookAppID, FacebookDisplayName, URL Types 下修改 URL Schemes 在 Build Settings 修改 entitlements 的路径 在 Build Phases 下，修改 Copy Bundle Resources ，移除没用的资源，把当前版本需要的添加进来 这样配置完，需要修改的东西集中了，运行的时候也很好操作，避免了每次频繁的打开项目。 当然看完上面的之后，你肯定就会想如何更好的管理，最好是连配置和修改这个过程都省略了，自动化到一定程度之后，就会带来另外一个问题，你连操作都不用的话，需要改动到里面相关内容的时候，你还是需要把你欠下来的补回去的，出来混，迟早是要还的。 补充说明： 实际使用过程中发现不同的 target 不能同时使用 Assets.xcassets ，只能使用完之后再单独添加，目前没有去深挖缘由，有时间再处理。（还是有点懒，还没到完全自动打包的地步） 脚本打包，你知道么？未来补充上我之前定制好的一个一键打包脚本。先占坑。用 Xcode 打包有时候挺方便的，但有时候也会挺麻烦的，比如你自己的测试机，好，那么连接 Xcode 很快就能调试测试，但假设你要输出包给其他人呢？或者打多个包呢？ 刚才引申出来，其实我们要解决两件事： 自动化打包 架设「包管理」 服务器（下面讲） 本着拿来主义原则，先看看友人们是如何解决这样的问题的。 参考：Xcode 8 后的自动打包脚本 好了，再来看看我这边的一套代码吧，虽然简单，胜在有用。 iOS 自动打包脚本 注：打包脚本建立在 Xcode 上已经可以输出对应不同的包的基础上 架设包管理服务器关于这个我也没有实际操作过，但我知道有这么一回事，以后可能也会尝试一下，目前来说需求不是特别大，之前公司大可能有，现在来说虽然各位老板都是用 iPhone ，但证书要不起呀。 有兴趣的参考一下这个： Mac OS X 10.10.2 启用 Web 服务器搭建企业内部自己的app OTA 当然没钱的看官可以采用其他云服务器提供的服务打包上传：iOS如何部署企业包，以供他人下载 设计师都看的，你看不看？了解设计规范，分辨率分布，你也可以很设计师。最近想重新思考一下分辨率适配，发现对分辨率的一个分布其实没有一个总体的概念，于是就想找一下哪里可以比较全面的看到市场上的分辨率集中在什么尺寸，这个网站「屏幕尺寸大全」也是偶然得之，我最粗暴的方法是通过友盟看线上已跑的项目主要的设备分辨率。这个后续我整理一个文档输出一下，有兴趣的可以查看，主要涵盖国内和泰国地区。 于是在这里也看到了关于不同平台的设计尺寸规范，感觉很有用，就收录了下来，以后可以经常去翻阅，回味一下。iOS 设计尺寸规范 与 Android 设计尺寸规范。 一次可以跟设计师有共同话题的机会，你抓住了么？ 关于 OpenUDID 的使用因为要发一个类似的游戏，申请了一个新的开发者账号，所以你懂的。 然后问题来了，昨天要发包了，发现生成的游客变了，不再是几个游戏共用一个了。其实我一开始也不知道有这么一个梗在里面的。花了点时间把代码看了一遍大概整理了一下思路： 第一次安装应用会通过 OpenUDID 生成对应的 UDID，然后保存在系统剪切板中并存在应用的本地存储中 下次启动的时候从本地存储中取 卸载游戏之后可通过剪切板获取 限制： 理论上使用 UIPasteboard 可以达成删除应用和升级系统都能获取到，不保证重装或者硬盘满了之后被清除 不同应用不能共用，bundle ID: xxx.xx.* 可共用（未确认） OpenUDID 作者已经发布声明仓库已废弃 所以这个解决方案，无法解决唯一标示问题，从官方开始禁止访问 UDID, Mac 地址后变得曲折起来，网上提供的比较靠谱的思路是采用 IDFA + KeyChain / UUID + KeyChain 来解决这个问题，我想问一下，这个不同的开发者的应用可以适用么？（待后续有时间研究确认一下） 该模块接触到的一些陌生的知识点： iOS 数据存储 NSUserDefaults的使用 UIPasteboard 粘贴板（iOS） 看这篇就够了 数据存储之归档解档 NSKeyedArchiver NSKeyedUnarchiver iOS-NSDictionary and NSMutableDictionary iOS 获取设备唯一 ID DSYMs 的作用？最近在分析一些线上 Bug 的时候发现在 Archives 栏目有一个 Download DSYMs 的按钮，不过每次下载都会找不到，看了关于 Xcode 帮助文档中 Symbolicate crashes 的介绍，提到他会存在于打好的包中，或者可以从 iTunes Connect 中下载，主要用于分析设备出现的 crash，看完还是有点一知半解，顺手 Google 之。 参考： iOS开发符号表(dSYM)知识总结 dSYMTools 于是后面每次发包就要顺路把打包好的 IPA 和 archive 留档下来，以便于更好的分析线上 bug。不过因为项目中涉及的大多是 C++ 的 Crash ，也未能得到更多的信息。 考虑要接入 Fabric 的 Crashlytics 辅助查看。接入过程很简单，可参考官方文档自行接入。 URL Schemes 使用详解最近在使用 FB 分享跳转到应用遇到一个问题，因为我手机里面安装了两个使用同样 FB ID 的 App，然后每次点击跳转的时候都是跳到另外一个 App 就感觉有个 Bug 在向我逼近。 分析了一下，发现这个问题跟 App 安装的顺序有关，同个 FB ID，早安装的会被唤起，后安装的不会，之前在做国内版本的时候也发现了这种现象，当时是在「正式包」登录结果跳转到了「企业包」，今天就试图揭秘一下，从其他 App 跳转到当前 App 的机制，而其中涉及到关键字是 URL Scheme，Google 之，URL Schemes 使用详解 发现这个东西用的好还是大有可为呀，也明白之前微信打开手机内 App 的姿势原来是这回事，知识匮乏限制了我的想象力呀。 之前在 App Review 的时候，网友也有提过关于检索项目中使用的 URL Schemes 有没有包含 Apple 禁止的关键字，现在看来更加明了了。 URL Schemes 使用问题如何判断是否安装某个 App 以及跳转到对应 App12345678// 判断是否安装 Appif ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@&quot;line://&quot;]])&#123; NSLog(@&quot;Installed&quot;);&#125;else&#123; NSLog(@&quot;No&quot;);&#125;// 跳转到对应 App[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;line://&quot;]]; failed for URL: “line://“ - error: “This app is not allowed to query for scheme line”原因: IOS9 中限制了 URL Schemes 白名单以外的 scheme 访问，解决办法: 在项目的 Info.plist 中增加 LSApplicationQueriesSchemes 配置，属性是 array 。把你需要用的 scheme 加进去就好了。 我这里加的是 line ，其它的第三方应用类似。 更多 你所知道好玩有趣的 iOS URL Scheme 有哪些？ 看这里。 下面是 xml 内容，可以直接拷贝。 1234&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;&lt;array&gt;&lt;string&gt;line&lt;/string&gt;&lt;/array&gt; 打不开对应的 URL Schemes因为 URL Schemes 类似于使用 URL 访问，所以需要对你请求的内容进行 URLEncode ， Lua 版本的 encode 代码可以参考这里： 12345678910-- 加密 URLfunction encodeURI(str) if (str) then str = string.gsub (str, "\n", "\r\n") str = string.gsub (str, "([^%w ])", function (c) return string.format ("%%%02X", string.byte(c)) end) str = string.gsub (str, " ", "+") end return strend -[__NSCFString stringValue]: unrecognized selector sent to instance 0x174429f40在使用 NSString 的时候，犯了一个很二逼的错误，特此纪念一下。 目标代码： 1NSString* shareMsg = shareMsg = [[dict objectForKey:@&quot;msg&quot;] stringValue]; 原因是：如果已经是 stringValue 就不需要使用 stringValue 去处理转化了。 可以使用以下代码解决： 123456789101112131415161718192021// 方案一：比较稳妥的解决方案NSString* shareMsg = NULL;if ([[dict objectForKey:@&quot;msg&quot;] isKindOfClass:[NSString class]] ) &#123; shareMsg = [dict objectForKey:@&quot;msg&quot;];&#125; else &#123; shareMsg = [[dict objectForKey:@&quot;msg&quot;] stringValue];&#125;// 方案二：扩展 NSStrinng 方法@interface NSString(JB)-(NSString *) stringValue;@end@implementation NSString(JB) -(NSString *) stringValue &#123; return self;&#125;@end// 方案三： 简单粗暴NSString* shareMsg = shareMsg = [dict objectForKey:@&quot;msg&quot;]; 我就是直接用方案三解决的，简单粗暴，都知道是 stringValue 还脱裤子放屁，简直多此一举，「防御式编程」也不是这么用的！ 参考看这里： [NSCFString stringValue]: unrecognized selector sent to instance iOS 下实现类似 Java 反射的实现把这一点拿出来说，主要是前段时间公司刚把 performSelector:withObject: 改成使用 switch，瞬间觉得淡淡的忧伤。当时主要不是我负责，所以我也就没有说什么了，但是做过项目你就知道的，当你写了很多需要跨平台回调的方法之后，你还要跑到一个类似「网关类」那里通过各种 case 然后去找到对应的方法实现的时候，你就明白使用「反射」来动态获取并调用的方案是多么的愉悦了。 目前 iOS 支持的实现类似反射的方法有两种： performSelector:withObject:（已不能使用，iOS 明令禁止，参见最新的 app review 审核指南） NSInvocation 发现第二种是刚好在跟这一个问题的时候： luaoc static function return type BOOL ，就顺便看了一下关于这一块的实现，发现了这么一个东西，记下来，好好学习一下。 NSInvocation 支持的使用方式 无参数无返回值 有参数无返回值 有参数有返回值 讲一下第三种其他两个就很容易理解了，代码节选自 LuaObjcBridge.mm，完整代码请到对应的方法下查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071......// 通过方法名新建 ClassClass targetClass = NSClassFromString([NSString stringWithCString:className encoding:NSUTF8StringEncoding]);SEL methodSel;bool hasArguments = true;// 有参数if (hasArguments)&#123; NSString *methodName_ = [NSString stringWithCString:methodName encoding:NSUTF8StringEncoding]; methodName_ = [NSString stringWithFormat:@&quot;%@:&quot;, methodName_]; methodSel = NSSelectorFromString(methodName_);&#125;else&#123; // 无参数 methodSel = NSSelectorFromString([NSString stringWithCString:methodName encoding:NSUTF8StringEncoding]);&#125;NSMethodSignature *methodSig = [targetClass methodSignatureForSelector:(SEL)methodSel];if (methodSig == nil)&#123; // do something&#125;@try &#123; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSig]; [invocation setTarget:targetClass]; [invocation setSelector:methodSel]; NSUInteger returnLength = [methodSig methodReturnLength]; const char *returnType = [methodSig methodReturnType]; if (hasArguments) &#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; // 通过 dict 把数据传过去，多个参数使用 setArgument 和 index 分别设置，使用 dict 可以设置任何想要的数据而无需扩展方法 [invocation setArgument:&amp;dict atIndex:2]; [invocation invoke]; &#125; else &#123; [invocation invoke]; &#125; if (returnLength &gt; 0) &#123; if (strcmp(returnType, @encode(id)) == 0) &#123; id ret; [invocation getReturnValue:&amp;ret]; &#125; else if (strcmp(returnType, @encode(BOOL)) == 0) // BOOL &#123; char ret; [invocation getReturnValue:&amp;ret]; &#125; else if (strcmp(returnType, @encode(int)) == 0) // int &#123; int ret; [invocation getReturnValue:&amp;ret]; &#125; else if (strcmp(returnType, @encode(float)) == 0) // float &#123; float ret; [invocation getReturnValue:&amp;ret]; &#125; else &#123; NSLog(@&quot;not support return type = %s&quot;, returnType); &#125; &#125;&#125;@catch (NSException *exception)&#123; NSLog(@&quot;EXCEPTION THROW: %@&quot;, exception);&#125; 以上代码就包含了上面的几种情况，这样你就可以愉快的通过 NSInvocation 动态访问到任何 class 下的 method 了，还支持把数据传过去。 iOS 下支持的布尔类型用 objective-c 我才知道我对「布尔类型」的认识还太少，跟布尔类型有关的有如下几个。 看此表格，以后别用错了哦。 name typedef header true value false value BOOL signed char objc.h YES NO bool _Bool(int) stdbool.h true false Boolean unsigned char MacType.h TRUE FALSE NSNumber __NSCFBoolean Foundation.h @(YES) @(NO) CFBooleanRef struct CoreFoundation.h kCFBooleanTrue kCFBooleanFalse 总结最近接触的 iOS 多了，有感于在 Android 方面有一定的认识，接触起来也不会一头雾水，而且已有众多前人趟过，随手搜索都能找到解决方案，更坚信自己要把问题好好记录下来，方便自己也方便他人。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Guide</tag>
        <tag>OpenUDID</tag>
        <tag>60分钟入门</tag>
        <tag>icon</tag>
        <tag>target</tag>
        <tag>URL Schemes</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏引擎架构展示]]></title>
    <url>%2F2017%2F11%2F11%2Fgame-engine-architecture-display%2F</url>
    <content type="text"><![CDATA[背景最近想对我认识的游戏引擎进行一个总体的概述，然而在我的脑海中搜索了一圈，发现我其实未能愉快的让整个架构展示出来，于是花了点时间整理和组织了一下，把目前的接触的给大家展示一下，希望看官你喜欢。 主体内容通用游戏引擎架构 摘自「游戏引擎架构」 Cocos2dx 引擎架构 摘自Cocos2dx Quick Cocos2dx Community 架构 从 「Cocos2dx 之 Lua 核心编程」中用 Pages 绘制的 后续目前只总结了两个，后面可能会对 Unity 和 Unreal Engine 也进行一个整理汇总，可以让自己更清楚的认识他们的不同与相同。]]></content>
      <categories>
        <category>Cocos2dx</category>
      </categories>
      <tags>
        <tag>Cocos2dx</tag>
        <tag>Quick-Cocos2dx-Community</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Xcode 遇到的问题集锦]]></title>
    <url>%2F2017%2F11%2F08%2Fthe-problem-when-I-use-xcode%2F</url>
    <content type="text"><![CDATA[背景不知你是否也跟我一样，在第一次开始使用 Xcode 的时候遇到各种各样的问题，反正我是遇到了。于是，写这篇博客收录一些在过程中遇到的问题，并尝试提供解决方案，如果有一些你也遇到了，希望能给你带来帮助。 更新日志 2017-11-08 init this news 2017-12-20 Xcode 的帮助文档 更新系统与更新 Xcode（ Xcode 9.2 升级带来的问题） 打包选择 Generic iOS * Device ? 问题Xcode 的帮助文档本身 Xcode 提供的官方文档是最齐全，最权威的，理论上你可以在这里找到任何你想知道的答案，虽然有一些坑是没有明说的，你知道的，但也不影响它成为你日常使用中来查询一些问题的好去处。 可惜没有中文文档，不过你可以使用 Chrome 浏览器翻译一下，勉强还是可以看的。 传送门：Xcode Help Xcode 中打开，在菜单栏 Help -&gt; Xcode Help 下打开 Xcode 兼容问题一个好的 iOS 开发理论上会安装多个 Xcode 来解决一些兼容性问题，包括设备升级了系统，但 Xcode 依然是旧版本的问题。 那么电脑中安装多个 Xcode 是可以解决这一类问题的。 安装多个 Xcode 最新版本的 Xcode 通过 App Store 下载更新 官方下载地址 Xcode 下载旧版本的 Xcode ，更改 Xcode 名字，把 Xcode_x.app 拖到应用程序即可。 除了安装多个 Xcode 还需要加入 iOS 的 SDK 版本。 安装 iOS SDK 找到 Xcode SDK 的路径： /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/ 获取 iOS SDK： 一般 Xcode 都会带有默认支持的 iOS SDK，升级 Xcode 也会把最新的加到包里面，但是对于一个稳定版本，就需要自己从其他版本的 Xcode 中拷贝过来了。 目前我收集到的你可以通过这里去下载： 百度云【不定期更新】 Development cannot be enabled while your device is locked.出现这种问题，解决方案：点击 设置 –&gt; 通用 –&gt; 重置 –&gt; 重置位置和隐私 原因： 手机连接 Mac 时，没有点击授权信任，重置一下，连上手机等 Xcode 把相关东西 copy 到设备就可以调试了。 打开 Organizer 卡解决： 打开 Finder， command + shift + G 跳转到 ~/library/Developer/Xcode/products 删除你「看不顺眼的」，速度提高杠杠的，推背感强。 因为在使用开发者账号登录的时候，为了方便管理，Xcode 帮你智能的缓存了列表，如果 APP 发布多了，打开速度就自然下去了，有时候你可以来一次解放。 更新系统与更新 Xcode本来觉得这个问题没必要提起的，但是最近在使用过程中还是吃了一些亏，幸好自己还是安装了多个 Xcode 版本才避免了悲剧。 事情发生在 12 月 5 日，那一天我刚更新了 Xcode 9.2 Release 版本，然后刚好晚上需要发包了，结果之前可以用的 Xcode 9.0 报了这样一个错误「ERROR ITMS-90534」图片可从下面链接查看，瞬间懵逼。系统是最新的 10.13.1（后悔升级，电脑变卡了，闪退多了），Xcode 9.2 ，你在欺负我的智商么？ 在网上搜了一下关于这个问题，不止出现在这个版本，8.0 升级 8.3 也出现了，从这里我就明白了，追求新版本是有代价的，升级这种事情要慎重。问题链接从这里进， Xcode 9.2 Upload to App Store fails with description length and invalid toolchain errors 除了 Stack overflow 上有反馈，Apple Developer Forums也是立马就有人跳出来。 目前保持不变，时隔小半个月，已经可以使用 Xcode 9.2 发布应用了，代码配置什么都没有更改，苹果爸爸，有 Bug 能通知一下么？这么随便，这么任性合适么？ 打包选择 Generic iOS * Device ?我觉得这个问题很蠢，但是你真的知道其中缘由么？ 好吧，我承认是因为我在打包的时候忘记拔掉手机，手快点了通过设备打包了。 然后各种担心，会不会跟直接使用 Generic iOS * Device 的不一样呢？会不会被拒呢？等等。 面对未知的东西，人就容易恐惧，所以我也不例外，本着求知的欲望，我还是要挖掘一下这个问题。 最后我在 Xcode 的官方帮助文档里面找到了答案，当然最根本的问题还是没有解决，但有一个权威的解答也是可以接受的。 1For iOS, tvOS, and watchOS apps, choose a generic device—Generic iOS Device, Generic tvOS Device, or Generic iOS Device + watchOS Device—or choose your device name from the Scheme toolbar menu. If a device is connected to your Mac, the device name appears in the Scheme toolbar menu. When you disconnect the device, the menu item changes to the generic device name. 表现上，两者是没有差别的。 参考链接： Create an archive of your app 一般打包推荐的步骤： 在 Xcode 下修改 toolbar 上的 target 指向为 Build Only Devices -&gt; Generic iOS * Device 去掉所有的断点，可以在 Xcode 中选择 Show the Breakpoint navigator 查看是否有断点保留着 那么问题来了，什么时候需要选择不同的 target 来打包呢？ 在输出静态库的时候需要指定不同的 target 并合并，这是考虑兼容性问题，不提供的平台的话，就会出现在要么是真机跑起来找不到，要么就是模拟器找不到。 1lipo -create 第一个.a文件的绝对路径 第二个.a文件的绝对路径 -output 最终的.a文件路径。 如何使用 Xcode 编译静态库，可以参考这个：Xcode 创建.a和framework静态库 新版本 Xcode 下在旧系统下运行报 Framework 异常解决1dyld: Library not loaded: /System/Library/Frameworks/UserNotifications.framework/UserNotifications Referenced from: /var/containers/Bundle/Application/245FDD8F-8BA5-46DF-96A4-EF6C84BA3361/dummy.app/dummy Reason: image not found 哪个 Framework 有问题，在 Link Binary With Libraries 中从 Require 改为 Optional 。 总结有些问题一定要自己经历过才知道，而庆幸自己遇到的问题都有前人踩过坑，以后遇上了未被开发的 Bug 再来总结吧，站在巨人的肩膀上就是舒服点。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录我在使用 Quick-Cocos2dx-Community 的过程]]></title>
    <url>%2F2017%2F11%2F01%2Frecord-something-when-I-use-quick-cocos2dx-community%2F</url>
    <content type="text"><![CDATA[背景每个人在入门一种新技能的的时候都会遇上一些坑，而这些坑也只有踩过才能更清楚的理解，从而避免再次踩进去，这一篇 Blog 我将记录一下关于我使用 Quick-Cocos2dx-Community 版本的问题。如果你也想了解一下，可以看看我的是否你也经历过。 问题 一直以为 Cocos2dx 的性能会很好，其实没有数据支持，都是假象？ cocos2dx 从 3.0 开始支持自动批量渲染，不过也是没能改变在需要渲染的时候的开销，笔者自己测试的时候发现在低端机上的瓶颈还是很容易体现出来的。 123测试设备： I9300(2012-5-3)测试 demo： quick/samples/benchmark(3.7 以下有提供)测试结果： 800 个 所以在使用的过程还是要关注性能的消耗，不要以为可以肆无忌惮的消耗，这个结果相对于我之前使用的引擎来说，半斤八两。 版本的改变，你是否已经准备好了？ 3.7 是一个比较大的改变，使用之前的版本的项目估计只能保持在 3.6.5 了，而相对于新项目，还是比较推荐 3.7+ 进行开发的，因为废弃了很多代码（当然有顺手的代码，也有低效的代码），但是也让引擎更加轻便。 我印象深刻的是在使用框架提供的创建文本的方法时，不同的方法耗时不一样，这个不细抠你真的不会发现。这是我简单写的测试代码，有兴趣的可以测试一下，记得设备不要太高级哦，高级的设备很容易忽略了很多问题。 建议：如果没有特殊要求，采用 cc.Label:createWithSystemFont() 进行创建普通文本吧。 1234567891011121314151617181920212223242526local socket = require("socket")local beginTime = socket.gettime()local label1 = display.newTTFLabel(&#123; text = "Hello, World 1", font = display.DEFAULT_TTF_FONT, size = 28&#125;):pos(display.cx, display.cy + 100):addTo(self)print("create label1 cost time = ", socket.gettime() - beginTime)beginTime = socket.gettime()local label2 = cc.ui.UILabel.new(&#123; UILabelType = 2, text = "Hello, world 2", size = 28&#125;):pos(display.cx, display.cy):addTo(self)print("create label2 cost time = ", socket.gettime() - beginTime)beginTime = socket.gettime()local label3 = cc.Label:createWithSystemFont("Hello, world 3", display.DEFAULT_TTF_FONT, 28):pos(display.cx, display.cy - 100):addTo(self)print("create label3 cost time = ", socket.gettime() - beginTime) 12345678910111213141516171819202122232425-- MacOS 上的结果create label1 cost time = 0.00021910667419434create label2 cost time = 0.00051999092102051create label3 cost time = 7.5101852416992e-05-- 提供 5 组在 i9300 上的测试数据create label1 cost time = 0.0022070407867432create label2 cost time = 0.0037410259246826create label3 cost time = 0.00059700012207031create label1 cost time = 0.00055098533630371create label2 cost time = 0.0039401054382324create label3 cost time = 0.00021910667419434create label1 cost time = 0.00037097930908203create label2 cost time = 0.014042139053345create label3 cost time = 0.00020599365234375create label1 cost time = 0.00038290023803711create label2 cost time = 0.003803014755249create label3 cost time = 0.00023102760314941create label1 cost time = 0.00037002563476563create label2 cost time = 0.0037879943847656create label3 cost time = 0.00079107284545898 而我去探寻这个问题的时候就发现，Quick framework 在为了提供一些更友好的借口的时候做了一些没必要的事，在 UILabel 的 ctor 中，调用了 makeUIControl_(self) 这个方法会耗时多 1ms. 虽然你看来 1ms 不多，但是作为一个使用频率特别高的基础 UI，特别是在列表中使用的时候，会在一帧创建多几个文本，就会造成卡帧了。所谓细数惊长计，能省一点是一点。 加密是否有用呢？ 看这一篇别人总结的经验，为了更好的保护自己的代码，你可以想想其他的加密方式，当然这个东西防君子而用，也是做一下初级过滤，如果你也有更好的加密方式，欢迎交流讨论，毕竟不想自己辛辛苦苦写的劳动成果别人一下子就借用了。 形同虚设的 cocos 默认加密 使用 GAF 转化 SWF 使用时，设计使用不同的格式，性能的差距是非常大的？ 通过对同个效果进行多维度测试发现，在使用图形元件的时候可以更大程度的保证 cocos2dx 可以使用自动批量渲染的形式减少 drawcall，从而提高效率。 总结每个完美使用过程都是经过细心调教的，而一开始你可能不会关注一些的问题，其实往往是因为没有什么契机需要去接触到，而当你慢慢品尝的时候，才会使你对自己所用的工具，所了解的引擎进行深一步的剖析，从而达到自己理想的状态。 多做测试，多做尝试，多做思考，就是我目前在使用 Quick-Cocos-Community 的状态。]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>Quick-Cocos2dx-Community</tag>
        <tag>使用过程</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我做过一些关于游戏的性能优化]]></title>
    <url>%2F2017%2F08%2F31%2Fthe-optimization-problem-I-has-did-before%2F</url>
    <content type="text"><![CDATA[前言更新日志 2017-08-31 第一次写完毕 2017-12-26 修改一两个错别字，改了一些语句，加了一个关于其他引擎的性能数据参考 待补充 文中提到的「去重」和「删除无用图片」的脚本 去年我觉得自己最大的成长就是从做出一个游戏到做好一个游戏的转变。也是因为这个，重新认识到做好一款游戏是不容易的。 性能优化是一个老生常谈的问题，而自己刚好做了这么一些事，就来写一篇博客总结一下，给之前的辛苦劳动画上一个完美的句号。 一开始接触性能优化我也是一头雾水，因为原来就没有接触过，或者有一些方法是前人已经总结的，你只需要这么办就好了，但到你这里，其实是一知半解的，所以做起来就蹑手蹑脚的。 经历的阶段回过来总结过去的经历，分成三个阶段。 死马当活马医 开始会开处方了 可以传教了 一开始就是，有什么方法好使就用，有什么可以尝试就试，也没有弄明白这样做有意义么？先干了再说。 后面就是，开始会规划，采用数据来支撑自己的优化，没有达到结果就要反思和重新寻找有效的措施。 慢慢积累一些经验之后，除了科普给组内还可以到外面随便说说了，这事咱确实做过了，不怂！ 再说一个结论，也是我的感悟吧。「不到万不得已，没必要优化代码。」 原因是，这一步应该是最后进行的，而且效率是最低的，还有就是在目前的手机运行环境下，代码性能的那点优化没有多大作用，只是心理安慰而已。 目标概述其实一开始并没有制定什么目标，只有一个比较模糊的想法，那就是做一款精品。对比竞品「天天德州」，也发现腾讯在这一块质量把控是有一个完整的流程，后面我们也是参照 WeTest ，借助 GT 采集游戏的基本数据，然后对我们自己的游戏进行评估和总结。 从结果上来看，单纯数据，我们游戏也不会太差，但是整体的玩牌流畅度体验不佳，在一些地方会让玩家等很久，而这些是数据不能反映出来的。 我们第一次采集到的数据，FPS 37+， CPU 占用 17.45% - 23.97%， 内存在 59-166MB，流量消耗 10MB。 参照 WeTest 发布的 中国移动游戏质量白皮书 提供的关于棋牌类游戏的几个指标，我们游戏还是有不少距离的，但不至于经常有卡顿。 白皮书中低端机（未列出）的几个数据： FPS 31.83， PSS 内存峰值 125.3MB， CPU 16.07%。 后面我们在数据指标中加入其他的考量标准，比如「低帧率」，这个可以更好的反映一款游戏的流畅度；而对于内存和 CPU 没有更高的要求；「游戏启动时间（冷启动和热启动）」，这个是玩家在点击 ICON 到进入到关键位置的时间；场景切换时间，这个没什么好讲的，主要考量是进入到房间玩牌的时间。 通过上面几个来反映我们游戏的质量是不是够硬，当然现在依然在继续做着。 后记：关于一些数据反映出来而觉得需要优化的时候，会因为引擎本身的性能而导致无法进行，这一块在自研引擎上体现的更明显，所以在选择引擎进行开发的时候最好能对引擎适用于开发什么游戏，能达到什么样的性能要有一个清楚的认识。 补充，最近用 Quick-Cocos2dx-Community 做了一个测试，发现在同等机型下（I9300）支持不降帧的最大帧动画个数在 800 个左右，使用 GAF 导出的一个简单动画也只是支持 200 来个，所以不要太乐观，能够清晰的认识到瓶颈所在，做起优化也能不含糊。 廖大做了几款游戏的一个测试，可以在这里查看，遗憾是没有输出一个表格，结论是在使用 webGL 渲染的时候性能最好的是 pixi 。 stars-benchmark 关于 Cocos2dx 本身的测试用例，我简单看了一下，已经有好多年没有更新了，数据也会在引擎的升级过程中会出现波动，而从结果上看，有一些反而越来越慢了，所以在性能优化这一块下手的话，什么版本也要注意一下。这里可以查看关于 cocos2dx 的一些性能数据。Performance-Tests 和 spreadsheets 性能优化方向汇总一下，考虑性能优化关心的几个方向： 平均帧率 流畅性（低帧率） 互动延迟 等待时间 内存用量 游戏体积 网络流量 耗电量 实施通过采集数据然后就发现了诸多问题，主要表现集中在，启动游戏慢（10s），弹框卡顿，玩牌不流畅，场景切换不流畅，滑动列表卡顿，动画不流畅，网络请求引起的卡顿，Loading 卡顿，耗电量大等等，而这些问题汇总起来矛头直指 IO，代码和资源过于臃肿，有一些实现确实过于耗费性能等等。 而需要在 30 多万行代码中把这些东西都处理好还是有点头疼的，所以我们需要制定优化标准和措施。 有一条标准就是，在保证目标的前提下（相关数据指标），优化都是相对的，一旦优化过了势必会影响其他的模块。 选择策略我们在过程中总结出来的有这么几条策略： 在保证内存不超标的情况下，可以尽可能缓存相关纹理和对象，必要的时候加入对象池 不要一次性加载所有的资源，可以按帧加载，异步加载 文本纹理其实很耗性能 单线程解决不了的问题，考虑多线程 纹理格式选择，RGBA4444 &gt; RGB565 &gt; RGBA8888 批量渲染是个好东西 要清楚的明白使用的引擎的瓶颈在哪里 关键指标再来看看几个指标跟什么关系最大。 FPS 除去 I/O 的影响， DrawCall 是最主要的因素，通俗一点理解，当前帧需要绘制的东西有多少 流畅性 理想状态是「在资源准备完毕」的情况，需要渲染的东西不多，自然就流畅了，当然跟引擎底层的渲染机制也有关系 互动延迟 这一块跟网络也有关系，有一些游戏不管你网络如何，该有的反馈先给了，后面再做「数据同步」就好了，那么这种的延迟就会低，但有一些是只有等到网络返回数据再展示页面，在网络好的时候，表现不明显，但是网络差的时候就恶劣了。 显示策略也有关系，比如我们之前遇到的弹框，有缓存的比没缓存的快，有分离 UI 视图的比没有分离的快，你要清楚知道用户点击这个按钮之后最想看到什么，优先提供就好了 等待时间 这一个跟游戏整体的「文件数量」和「文件大小」有关，理论上加载大图会比加载散图快 网络延迟也有关系 内存 游戏中占用内存最大的部分还是纹理资源（图片，文本图片），代码占用反而不多，当然 内存泄漏 的问题要持续关注 游戏包体积 主要跟图片，音频，视频，第三方库和 SDK 有关 网络流量 跟游戏的数据交互量有关了，其次配置信息能提前下载，下载的图片，能缓存就缓存起来 耗电量 耗电量会大，CPU 就高了，而 CPU 高跟计算量和单位时间运行处理的数据量有关 好了，了解了之后我们就开始讲一下我们做过的一些优化行为吧。 我们做了什么？图片处理 去重 去重的意义在于减少重复的图片对拼图造成一定的影响，也可以减少一定的包体积。 为什么有这种情况？ 因为在开发过程中不同功能反复用到同一张图片而设计提供的时候多给了，客户端没注意从而引入了。 一开始要解决这个问题，头大，人工处理会累死的，整个过程将是枯燥无味的，也是通过这个，我慢慢采用 Python 来处理类似的问题，后面发现确实挺有用的。 讲一下解决思路： 首先，找出图片目录下的所有图片，并用 list 存储所有的图片路径，然后计算出图片大小，相同的话再计算 md5 值，如果两个都相同，就认为图片相同了；其次，删除掉相同的图片，保留一张，我其实是把他们移到其他目录，并留下操作日志最后，通过遍历所有的代码和布局文件进行替换，完成整个过程。代码后续再补充吧。 去除无用的图片 这个主要解决跟上面的情况类似，减少包体积的。 解决思路： 首先，建立图片路径的索引，图片目录的比较简单，代码和布局文件中的采用「取并集去重」其次，对两个大索引「取差集」再取「交集」就能找到最后哪些图片没有被使用了最后，肯定有误杀，还要把误杀的救回来，这一块通过人工检索，把误删的通过字符串匹配救回来（命名不规范导致） 拼图 这一块的效果是很显著的，提高读取图片的速度，对渲染效率也有一定的提升。拼图的规则首要规则是，同个场景或者布局的图片尽量拼到一张图片里面，次要规则，尽量消灭散图，因为提升 IO 的效果真的很显著，大概有 20%-40% 的提升。 除了对图片进行拼图，其实要更好的效果，需要对布局也进行调整，这样效果会更佳。因为引擎在渲染的时候，如果想对一些节点进行「批量渲染」，那么最好的状态的，要批量渲染的资源在一张图片里面（同个纹理），节点是连续的（减少纹理切换的开销），所以我们按照这个进行调整，实际上这一块是很烦的，一动了之后代码也要修改。 看实际的时间，可以考虑先拼图再改布局。 压缩图片 压缩图片是一个有损的过程，一般如果不改 RGBA 的话，只是减少了图片本身的大小而已，改了 RGBA 才会影响 GPU 内存大小，加载图片到内存只跟图片的宽高有关。如果是 JPG 格式的图片，可以采用 RGB565 的纹理格式放上去看一下效果，可以的话就用，个别可以列出来单独处理。 这边采用的是 TinyPng ，国际惯例，还是采用脚本自动批量压缩，记得准备几个 AppKey ，一个 key 一个月最多只能压缩 500 张图片。 另一条压缩图片的操作效果也是立竿见影的，我们设计分辨率是 1280x720，（1G 内存 CPU 双核）加载一张背景图片的时间是 120ms 左右，如果把图片缩小到 960x640 ，加载时间可以减少一半左右，大小减少 1/3 ，显示效果无异。 天天德州对背景也是单独处理的，不过他是采用把 1280x720 的背景通过裁剪拼图改成 1024x1024，这一个是考虑一些低端显卡，在处理的时候把宽高扩展到 2 的指数幂，那么用 1024 比较理想。 我们还做了另一件事，我感觉是提升更明显的。对一些左右对称的背景，只保留一半，剩下的通过镜像生成，再合并成一张。是不是有点流氓，不过使用条件也比较苛刻，我们项目刚好有不少大背景就是这样的，所以很受用。 提高渲染效率 减少节点数 有些布局确实就是采用几个节点来做一个节点也能做的事情，当然也有一定的原因在里面的，但从过去来看，影响最大的就是我们喜欢把背景和其他其实可以合并成一个节点的，分成两个来使用。使用高通的 AdrenoPrifiler 查看一下渲染效率，就可以很清楚的看出来，百分之七八十的时间就被他们（大背景，大弹框）用了，其他一些小图片只有一点点开销而已。 为什么要分成两个，最大的原因是，在图片拉伸的时候，上面的这个节点一般不采用拉伸，跟背景一起拉伸的话容易变形。 我们在一些布局中，使用了「空白图片」来消费一些事件，这些可以采用「空节点」替换，达到同样的效果。 其他一些是跟业务有关的了，减少节点数还有一个方式就是「动态合并节点」，即在布局中用的几个，如果是静态的，那么可以采用动态合并的方式处理一下。但要考虑一下图片的设计宽高和合并生成的图片的宽高，在高分辨率的手机上，内存占用会大很多。 从这里就可以看到，内存和渲染的关系很复杂了，不是我想改就能改的了。 拉伸图片和合并图片 一些图片其实可以采用拉伸的，但设计提供的却是一张整图，这个其实是很浪费的，采用拉伸的方式，只是有一点 CPU 的开销外，总体上利大于弊的，小体积，加载快，你怎么能不心动呢？ 合并图片这一块，在按钮和按钮上的文本表现尤著，如果不考虑多语言版本，其实合并起来会更好，就算多语言也可以通过一定 命名规范 和 设计辛苦点，统一输出 一下，可以减少一半的开销。文本也是图片。 批量渲染 批量渲染的意义在于统一打包一次输出到显卡渲染，可以提高渲染效率。因为在很多时候，GPU 的工作量是不饱和的，一次性多提交点东西给 GPU 是很有必要的，不然 CPU 累死累活， GPU 却在打酱油。 批量渲染的好处是很明显的，渲染效率可以提高，在一定程度上可以减少包体积。比如我们把 52 张扑克牌采用这种方式渲染，效率更高，同时图片大小减少了 80%。 在做一些粒子效果，或者同时有多个筹码要渲染的时候，表现也是很明显的。 启动缓慢 App 启动的三个阶段 点击 ICON 到进入游戏的过程（这一块基本上控制不到） 进入游戏入口到准备资源完毕 这部分一般包括两个阶段（启动 Lua VM 之前和之后），这一块最主要的就是初始化一些对象，当然还有一些 SDK 的初始化（考虑开线程处理），之后会有一些系统数据要准备传给 Lua 端 显示界面 加载 Lua 文件，我们项目采用的是散文件一个个加载的，为了解决这个我还把 require 重写并统计出加载比较费时（20ms）的文件，我以为我们项目一开始加载的应该不会太多，结果发现 1 千多个文件都加载了，这想快也快不起来呀，解决的话，启动的时候只加载必要的，后面在空闲的时候再把其他一些满满加载进来，当然一些没必要加载的可以等到用的时候再加载 另一种解决思路是，使用 zip ，把所有的文件打成一个包，这样加载可以很快，后面重新再 require 的时间开销也很快 加载音频文件，这一部分的开销，也挺大的，而且一般也会预加载。 加载布局文件和场景的图片，分帧加载，分离视图完美解决 切换后台再回来 原来我们这一块会重新加载一遍纹理，所以回来会黑屏几秒钟，后面我们不清空纹理的方式加快了回来的时间 应用内业务的启动相关 打开一个弹框 打开一个场景 打开 XX 这里说一下比较彻底的解决方案，也是理想的解决方案，统一样式，提前加载好。这种是最彻底的，也是最有效的。 当然在项目已经成型的情况下，很难，很难，那么我们的统一做法是，分离视图，分帧加载，这种也是比较有效的方式，先展示背景，剩下的界面分几帧加载完，这种方式玩家可以最快看到界面，后面刷一下满满出来，会比玩家等个 1-2s 然后全部看到会好很多，当然再补充一个动画上去，就可以很好的掩盖这个效果了。 如果遇到一些可以缓存起来的「公共控件」，在 移除的时候缓存起来，也可以加快启动，比如多个房间通用的头像类。 统一管理弹框其实这个应该是一开始就要设计好的，但当时我们做这个的时候只设计了一个关于弹框的基类，而管理类却没有，在设计初期，也没有那么大的需求，如果你一个游戏只有几个弹框，那么太复杂确实意义不大，但项目慢慢做大，久了之后，一百来个弹框的话，就很有必要管理了。 先说我们存在的问题，弹框都是在各个场景自行加入的，从使用上来讲，自己管理构造和析构，缓存，动画等等，容易出现析构遗漏，导致内存泄漏，不同的弹框在实现差不多的情况下，有不同的实现，包括一些动画也会写好几份，没有一个统一的行为；资源管理也混乱，调用关系不明确等等。 优化这个的主要目的，一方面方便管理，另一方面也是在统一规范之后对弹框有一个合理的要求。我们的要求是： 第一次打开和缓存打开的时间消耗要接近不能超过 30ms 使用者不需要自己管理弹框的析构，通过构建的时候传入参数 加入高斯模糊背景（可以在弹框出现的时候隐藏底下的场景，减少绘制，减轻压力） 采用空白节点消费事件 最好都能拼图处理 一些效果用 shader 替换 弹框管理的一些要求： 调用者只需指定一个弹框 ID 就能在任何地方创建一个弹框 不需要管理动画（弹出，收起） 支持预读缓存 不需要管删除和释放（通过参数指定） 支持多种类型（Toast, AlertDialog, Tips），这个后面没有实现，也不是必要的 通过上面的一个操作之后，我们可以更好的保证弹框的显示效率，也能方便开发友好的管理。 ListView 优化把这一块也拿出来讲着实是因为我们目前的 ListView 流畅度饱受吐槽。 最烂的设计，每个 cell 都是动态创建的，无限在后面追加。 稍微合理的设计，加入缓存，加载的时候采用延迟加载，一次加载几个，这种体验会比上面的好几个 level，但对内存的占用略大。 我觉得合理的设计，采用复用 cell 的形式，控制每个 cell 的内容，优先显示背景，待 cell 稳定下来之后再显示全部内容，如果有文本考虑缓存文本，通过数据来驱动，几个 cell 创建速度快，滑动也流畅，堪称 ListView 届的楷模。 如果你不清楚如何设计一个滑动流畅的 ListView 这个思路可以借鉴一下。 讲到 ListView 就不得不顺便提一下 ScrollerView，滑动相关的很多都会继承自它，但 ScrollerView 存在的一个问题也是跟 ListView 类似，一开始创建的时候耗时久，并卡顿的问题，我们习惯采用「分帧加载」的形式缓和，并在当前加载完毕之后开始预读一些 cell ，但还是不要一个 ScrollerView 加载过多项，内存占用会随着项越多越大。 数据请求优化提起这一块，能做的操作还真的不多，而我们遇到的问题也是其他项目经常遇到的。 优化的做法，我总结一下： 更快的请求 更少的数据传输 尽量少的请求 我们做过一个统计，每个 Http 请求的耗时大概是 15ms ，刚好一帧的时间，但在使用的时候不会是只有一个 Http 请求，掉帧就成为必然了，一个网络请求在网络稳定的情况下回来差不多要 120ms ，相对于 Socket 的返回确实长了一点，而且数据量重复多，但数据量可以稍微大点，如果有条件或者对延迟有要求，还是采用 Socket 进行数据通信。 一般现在的 Http 请求都会加密，我们也不例外，通过分析发现加密耗时大概在 8ms 左右，通过重构优化减少了一半，只要 4ms ，想不明白的是再调用底层库处理的时候耗时 7ms，我认为这个过程应该是基本不耗时的，但分析发现，他的时间一部分在处理堆栈的时候，还有一部分时间是创建一个 Http 请求上，于是在这里引入多线程处理，数据传过来接下来你就等回调好了，这边帮你搞定。这样总体下来，把一个请求时间减少到 5ms ，这样原来一个请求的时间可以连续发起 3 个了。意外收获是顺便解决了一个内存泄漏的问题，处理完回调之后数据都留在内存里面而没有删除，虽然有的只有 1-2k ，但有的却有 50-60k ，积少成多呀。 请求方面的效率解决了，如何减少数据量也是需要考虑的问题，时刻想着用户是在一个网络带宽小的环境，用户的流量都是要付费的，那么减少一点是一点， Gzip 是一个比较通用的方式，在成熟的 Http 库下都支持，而且效率还可以， CPU 的占用还是比较小的，数据传输量可以减少 60% 以上，是不是百利无一害？ 最好的情况是减少 Http 请求，是的，我们可以。这里减少有两层含义： 客户端通过缓存数据减少请求 能一个请求搞定的就不要用多个请求处理 讲一个我跟同事讨论的，不过要求比较高，不好实现，需要改底层。合并多个 Http 请求，用一个请求的消耗，完成几个请求，是不是听起来就很高大上。我曾经在 Skynet 尝试封装和解析过一个 Http 请求，底层也是采用 Socket 方式来处理的，那么这种封装多个请求理论上是可行的。有兴趣可以尝试一下。 当然有条件的话，还是用 长连接 的方式来请求网络通信，速度更快，数据利用率更高。 优化动画动画相关的优化，我觉得最大的成就就是把内存和显存都减少到原来的 1/3 ，当然还有其他的优化操作。 我们这边动画最突出的问题就是内存占用大，不流畅，动画单一，做动画比较耗时且容易出错。 表现就是，多使用帧动画，播放动画的时候有一些其他的操作，主要是 IO 操作，纯代码写的动画，过程繁琐，有些用法不规范导致一些泄漏。 我们优化的做法： 采用缓动，加入贝塞尔曲线 使用工具将设计的 Swf 动画直接转换成可以读取的格式（BabeSwf/Gaf） 动画使用到的资源提前加载 配合设计调整动画效果，在允许的范围内减少动画尺寸和减少帧数 这一块的操作比较繁琐，需要反复测试和同设计反复商榷。 内存泄漏检测内存也是游戏关注比较多的问题，特别是前几年设备的内存没那么大的时候，对内存的要求是斤斤计较，但现在时代进步了，对他的要求没有原来那么高了，但如果要适配更多的机型还是要注意一下，我们对这一块的要求没那么高，于是该用的就用，别客气。 内存泄漏一般来讲都是对于没有垃圾回收机制的语言而讲的，但也不是说他们没有。 关于 Lua 的内存泄漏，一般指 已经没有被使用了，但外部依然还有引用存在的对象。 特别需要提防全局表 _G，经常一不小心就把一个 local 的 变量变成全局的了。关于这个云风大大有一个工具可以借鉴一下，snapshot，不过从我们项目上看效果还是不佳，所以你最好还是了解一下 Lua内存泄露检测原理，然后自己写因地制宜的工具。 而检测是否有内存泄漏比较好的 Tips 就是开启每帧垃圾回收，看 Lua 内存的总体有没有增长，有的话你就需要注意了。 12collectgarbage("collect") -- 为了有干净的环境，先把可以收集的垃圾收集了 collectgarbage() 还有另一个操作就是在代码中设置合理的步长和垃圾回收的时机，这一块的可以详细看一下 Lua 的垃圾回收 API。 1234-- 我们使用的一个配置-- 不同项目的值会不一致，可以多改改跑一下看看效果collectgarbage("setpause", 150)collectgarbage("setstepmul", 5000) 既然 Lua 内存泄漏的情况比较少，那么还有内存泄漏，那就证明是其他地方出现的咯。特别是像我们游戏采用 C++ + Lua 的，一不小心就会出现一些 C++ 的内存没有释放干净。之前我们就有找到一些，申请了内存却没有释放掉的，虽然每次只有 4kb ，但也是泄漏。这一块的话，推荐在 Mac 下使用 Instruments 工具来检测 iOS/OS X内存管理(二)：借助工具解决内存问题 ，感觉更友好一点，还有就是通过 静态分析，人工缩小范围 的方式，多种方式并用。 Android 下的话可以引入 LeakCanary 库辅助，除了这个就是使用 dumpsys 命令了。Android 下的话可以关注一下 Webview 的内存泄漏问题，我们项目有一大部分内存泄漏也是因为它，这一块请自行 Google 之。 内存的几个大类，Lua 内存， Native 内存（ 图片／C++ ），堆内存，纹理内存。 纹理内存也是一个需要关注的地方，有一些确实是你要缓存起来的，但有一些也是应该释放掉的，你要持续关注咯。 关于内存泄漏这一块的，我也还在持续关注和学习中，总感觉还是没有 Get 到一个要领，解决起来特别头疼，如果你有很好的方式欢迎告诉我。 总结这篇文章断断续续写了几天，回过头来看，确实不好写，也写的有点乱，旨在把我所了解的和理解的说出来。虽然大部分是汇总一下过去做过的优化，但是涉及到的一些细节，还是需要去回顾一下，才能梳理清楚，通过一篇文章来整理陈述一下，也算是加深了印象，也希望要做性能优化的你们有所帮助，而我们项目在经历这些操作之后，性能确实提升了一个大台阶，这一点还是值得欣慰的。 如果你也有良计，欢迎互相探讨，学习进步。]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>optimization</tag>
        <tag>performance</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这些年我遇到过的网络问题]]></title>
    <url>%2F2017%2F08%2F31%2Fthe-network-problem-I-has-encountered%2F</url>
    <content type="text"><![CDATA[背景做网络游戏开发的过程中多多少少会遇上点事，有时候一些问题因为自己的知识匮乏而变的莫名其妙，而也是在这个过程中重新认识这个知识的好机会，这篇文章，我打算记录一下我曾经遭遇过的一些网络问题。 问题集锦Socket 丢包问题？先说结论，理论上基于 TCP 协议是不存在丢包问题的。 为什么这么说，因为 TCP 协议的定义就是这样说的，一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。 而可靠的意思就是 TCP 使用校验和、确认和重传机制来保证可靠传输，如果存在网络不可达或者网络弱的情况，TCP 是会告诉用户，有东西没发送成功，我要中断连接了。 所以从这个角度去考虑，在 TCP 层，不存在丢包问题，那么为什么还会有丢包的问题存在呢？这一块我们之前也做过分析，也吃过不少苦头。这里就猜测一下，仅个人见解。 总结起来，我觉得最主要的问题就是应用层封装的网络模块处理逻辑不严谨导致的丢包。 偏底层的解释就是 Socket 在处理粘包的时候抛弃了，这一块可以做点文章，避免这种情况，我说一下一种有效解决的思路，对所有的包／部分重要的包约定重传。而我们之前的 Socket 模块封装的时候对这一块的处理就是，抛弃了。 后面自己封装前后端协议的时候对这个问题的理解才慢慢深刻起来。 Socket 在处理收发的时候一般都会采用缓冲区，而在处理缓冲区的时候就会出现多个包在一起或者一个包被拆成多个的情况。出现丢包就是这一块的逻辑没处理好引起的，我们协议定义的时候都会把每个包的长度放在协议头，采用这个来确保可以正确的读取整个包的内容，但如果存在半个包的情况的话，会缓存起来，等待下个流过来，而恰好就是下个流迟迟未来，而来的不是刚好对应的那个包（网络拥塞引起的）那么这边要处理新包，就把那半个包扔了。一丢就会造成下个半包读取有问题，连锁反应知道下个有完整长度的包过来。关于粘包的问题可以看看这个，Socket/TCP 粘包、多包和少包、断包 这种是由于不稳定的网络引起的，所以如果是这个问题，应用层可以针对包的重要程度考虑是否从应用层通知 Server 重新发送这个包。 偏上层的解释是其实 Socket 断了，但包已经从服务器发送出去了，重连回来之后没有重新确认（很多时候都不会处理）导致在断线期间的所有包都丢了，重连的时候一些关键信息遗漏了。解决这一类问题比较偷懒的做法就是关键信息都在重连包里面重新设置一遍。这个问题在我们处理的时候往往忽略了。 通过心跳检测还是通过 Socket 事件来处理 Socket 连接问题？先说结论，目前我会采用以 Socket 事件为主，心跳为辅的方式来处理 Socket 连接的问题。 再说说背景，之前因为没有好好捋清楚我们这边提供的 Socket 模块的相关逻辑，导致出现，在连接异常的时候（收发包异常）重新建立 Socket 连接，而收到 Close 事件的时候也进行重连，这样有问题，出现多条 Socket 同时连接，或者重连时出现打开 Socket 发现还有 Socket 未关闭。 自我总结一下这一块问题，有两个点。 没有捋顺逻辑的影响就是处理过于混乱 Socket 的 open 和 close 都是异步的 先记录问题，等会再说解决方案。 然后就想，那要不就只用心跳来检测好了，但是后面发现了两个问题是因为纯心跳检测引起的。 检测时间过长，导致不能及时响应。 （30s 才能知道结果） 在有代理的服务器上，心跳检测是正常的但是却没有正确的连接上 Server 通过上面的问题，回过头再来看如何设计一个更好的 Socket 处理逻辑就很明显了。 首先讲一下 Socket 的几个事件，连接成功，连接失败，关闭事件，收包事件（正常收包，收包异常）。那么什么情况会返回这些事件也要清楚。 连接成功 这个比较容易理解，连接成功就会收到 连接失败 一般情况都是服务器不可达，触发了本身的超时，或者网络不可用（Wi-Fi 有信号无网络连接） 关闭事件 可以是客户端主动断开，也可以是服务器主动断开，也可以是网络中断（比如利用工具 TCPView 强制关闭 Socket，客户端发送一个 RST 的包给服务器） 收包事件 这个就是我们正常的解包事件，同时也包含解包错误的情况 单纯靠事件来检测貌似也是可以很及时的处理 Socket 的连接问题了，但是有时候连上的 Socket 不是业务 Server 的时候，这些事件都正常，你给服务器发包它不会回你，那么怎么解决呢？ 是的，需要一个业务心跳包来辅助。 汇总一下是下面这张图，心跳检测通过在 Socket 事件中通过时间值来通知是否需要中断就好了，这样只需要启动一个检测就好了。 注： 登录／认证包是为了提高连接上服务器效率而存在的，如果偷懒，直接采用登录包就好了 启动心跳包，只在登录成功之后开始，且模块独立，只需要管什么时候发送或者关闭就好 关闭的时候，正常的不需要额外处理，因为客户端主动关闭的之前要么就是异常导致了，或者就是要关闭 Socket，一般也会有对应的 Open 事件 定时检测也是在 Socket Open 的时候就开始 异常的时候，由 Socket 的事件来驱动，正常的时候通过业务心跳来驱动，理论上可以很好的处理各种问题。 上述问题不包括的有：设备切换前后台，Socket 事件要怎么处理，如果有 Socket 包堆积，是否要处理，（如果处理，设备在回到界面的时候因为多个消息同时到来，动画或者什么会跟放电影一样），open／close Socket 的时候采用异步，那么就需要对 Socket 进行业务的区分，一些时间的设置可以动态调整，目前只是一个参考。 弱网问题有何良计？结论先说，一旦网络有问题，做什么都无法改善，所以省点心吧，但一旦网络稳定了，你要快速的帮客户端连上。 既然结论都说死了，那还有什么意义呢？ 这里其实还是要分情况的，弱网有一个比较突出的表现，那就是高延迟，一种是包太大了，一种是包很小。前者的话可以通过压缩数据，减少包体积来解决，后者，不好意思，网络的问题，我做什么都难以有效。 如果你相信 TCP 的话，那么它其实为了给你完整的数据，一直在给你拼命尝试重传包的，而客户端这边的网络确实不好，只能中断掉，当然也可以考虑换掉 TCP ，不过这样的难度比较大，有兴趣的可以了解一下 KCP 回到刚才的问题，我们模拟一个场景，如果你进入到电梯里面，网络不好了，这个时候其实可能只是延迟高一点而已，但是升降了几层之后，网络完全没有了，那么是你，该如何在用户离开电梯之后让其更快的回到游戏呢？ 尽可能让双方传输的网络包小 可以采用 gzip 压缩 多用缓存数据 尽可能的重试 断网了你要第一时间知道，并进行多次尝试，必要的时候可以让用户帮忙 没必要的结果就不要通知用户了，用户比你想象的聪明 之前我们就是很多消息都告诉用户，其实用户只关心结果 体验优先 网络卡了，不要让用户什么都操作不了，没有什么比这个更糟糕了 就算包没发出去，但是对应的动画可以先播放 提供更优质的网络链路给客户端 通过给不同地区不同运营商的用户提供延迟最低的高速通道 依赖大数据分析 好吧，这是我的结论和方法，不知道能不能帮到你，在游戏上线前最好还是做一下弱网测试，一方面，可以知道自己的游戏能在什么环境下流畅运行；另一方面，弱网检测可以发现不少原来在正常网络下无法发现的问题。 Socket 缓冲区设置过小导致无故关闭问题？先说结论，64K 是 TCP 能传输的最大包大小，可以试试。 之前我们游戏在一个场景下出现 Socket 断开了，之后就连不上了。查了好久都没有发现什么问题，一开始 Server 在应用上层，打各种日志，无果，最后开始操刀底层的处理逻辑，发现在服务器发大量包的时候容易出现 Socket 断开的情况，而客户端也是要进行多次相同操作才会出现（60 次左右吧），这是要有多蛋疼才会对同一个网络请求进行这么多次的尝试，我们公司的测试就会。 最后定位到这个问题是因为 Server 设置缓冲区的时候设置过小（20K），而在需要发送大量数据的时候缓冲区一下子就被填满了，导致溢出，Server 强制断开 Socket，然后客户端又重连，然后 Server 再发送大量数据填充缓冲区，如此反复，客户端就连不上了，Server 也没有把数据发送出去。 后面 Server 把 TCP 缓冲区设置到 64K 才解决，当然这也是解决了 20K 缓冲区的问题，但是 64K 的问题依然没有解决，记得没错的话， TCP 协议的滑动窗口大小也改了。 Server 没有收到客户端发送的协议，这不科学？结论，在可靠网络协议下，Server 没有收到包，那是你客户端根本就没有发送成功，还是看看代码吧，少年。 背景，之前我们遇到过一个莫名其妙的问题，在手机上关闭网络之后，回到登录界面，重新连接网络之后进到原来的场景下，能收到包，发不出任何包了。 当时拿到这个问题的时候也是一脸懵逼，无从下手，一开始打日志查看上层逻辑，也发现客户端有发包，Socket 也没有断开，而 Server 却说没有收到客户端发送的包，包让「旺财叼走了」？ 好吧，使出大招，我用 WireShark 抓包，我抓包看看，如果客户端真的把包发出去了，我毙了那 Server。激动了。 而通过抓包发现，包确实是有发的，只是没有发送出去的，我忍住操家伙的冲动找了一下我们公司封装 Socket 模块的哥们，把抓到的 Socket 包和客户端日志发给他看，看看为啥客户端发包了，但包没有到达网络层。 有一个日志是我这边忽略的，那哥们一下指出来并定位这个日志出现的条件，socket 没有连接上。 1socket: write begin non-connected 后面重新梳理一下客户端逻辑，客户端底层在网络断开的时候会进行多次尝试，而每次重连，我们这边会让 Socket 的名字累加，Socket_1，2，3，… 而重连回来的时候收包的 Socket 复用的是 Socket_xx 了，而发送用的还是 Socket_1，收和发都不是同一个，怎么可能处理的了呢？ 最后处理的解决方案就是在回到登录界面的时候清除 Socket 引用，在处理 Socket 连接那块把 Socket 引用对象删除，只是两行代码，而实际解决却花了 2 天。 把这个问题拿出来说就是为了提醒各位客户端大大们，在定位问题的时候，除了我们尽可能要做的尝试之外，还要忍住，忍住，静下心，静下心，一切莫名其妙的问题最后可能就是很傻的一个错误导致的，不过奇怪的是，这个复现路径也不复杂，为什么之前没有暴露出来呢？ 防攻击该怎么办？做网络游戏不可避免的问题就是如何防止 DDoS 攻击呢？ 结论，钱要多，咱就不怕事！ 之前跟同事聊起这个问题，他说他们公司因为这个问题导致服务器瘫痪了几天，导致公司日活在服务器正常的时候掉了一半，当时他们老板也知道了肯定是竞争对手搞的。 而 DDoS 攻击的问题确实无解的问题，所有的客户端连接都是有效的，只是架不住那么多并发呀。 上次刚好重温了一下关于三次握手的时候，里面也提到这个，所有的请求只进行一次握手，服务器回应 SYN-ACK 之后等待客户端发确认包过来，而处于 SYN_RCVD 状态（超时没有回应会断开），而占用了服务器资源。然后攻击者换另一台客户端继续操作，如此反复导致大量的服务器资源被占用，而正常的服务就不能进行。（后面确认了是 SYN 攻击） 我不清楚现在这个还是否存在，有一个提到的解决方案是服务器主动发包给连接的一端，如果没有回应就直接断开，避免资源浪费，当然我理解 DDoS 之所以成为世界难题，肯定还是架不住大量的肉鸡发起的海量请求。 那么如何在 DDoS 来的时候不要太被动呢？ 找一个靠谱的运营商 跟 DDoS 攻击者进行游击战 这里的两个操作都是需要资金支持的。靠谱的运营商能提供这种服务的，费用肯定也是不低的，而运营商能做到的也只是相对的，比如你随便找的运营商 1s 可以承受 10G 的流量，而高价格的可以承受 200G/s 的流量并且会帮你过滤正常的流量，一旦超过了，依然会让你的网络降下来，然后再加上服务端代码写的不咋地，实际一来就不行了。 如果是按照流量算钱的，那么我想快哭晕了。 跟 DDoS 打游击战指的是服务器知道被攻击的时候可以采用自己的一套逻辑通知客户端更换可用的服务器（多台），需要客户端和服务端共同完成，另一个就是从硬件级别阻断流量的进入，检测到 DDoS 之后直接关闭网卡，让服务器处于不可连接状态，服务器提供内网入口，由其他服务器转发正常的流量过来，关闭网卡的机器会休息一会重新打开，如此反复直到攻击结束。 如果你的服务器都被黑客攻克了，且同时被请求，那么我只能说，没办法了，我们只能死磕到底了。运营商，我看好你哦。 总结暂时先总结这几个问题，我相信在过程中不仅这么几个问题的，只能想起或者遇到的时候再来总结了。 希望能对你有所帮助，祝生活愉快，工作顺利！]]></content>
      <categories>
        <category>Skills</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>socket</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结刘未鹏「学习习惯」系列]]></title>
    <url>%2F2017%2F08%2F29%2Fstudy-habit%2F</url>
    <content type="text"><![CDATA[前言最近发现自己之前定下来的一些目标都没有去实现了，因为这样那样的问题，回想之前在翻看刘未鹏博客的时候，对于他的一些思考方式和学习习惯印象深刻，但具体也记不得了，为了更好好的借鉴和参考，于是重新看了一下，并记录下来。 总结自己的问题： 焦虑 注意力不集中 有一些坏毛病 主次不分 带着这些问题，然后重新看了「一直以来伴随我的一些学习习惯」一 二 三，记录了下面这张思维导图，给有需要的也一起看看，共勉吧。 内容 总结方法了解的再多，不实践都是空的，无用的。好的用户习惯总是难以养成，这个是长久以来身体最诚实的选择。做什么除了觉悟还有就是坚持，坚持，再坚持！ 希望自己可以变得稍微看的顺眼一点。 最近我也想去做个 5 年计划了。]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>study</tag>
        <tag>habit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步更新 fork 的仓库最新的更新]]></title>
    <url>%2F2017%2F08%2F22%2Fhow-to-fetch-git-update-from-forking-reposistory%2F</url>
    <content type="text"><![CDATA[背景最近在项目组内部尝试使用 Pull-Request 才参与其他人的开源项目，然后一段时间之后发现 Fork 的项目更新了，我这边的代码也有更新，但是还不想 Pull-Request ，于是就需要从那边同步代码过来，这里记录一下如何从 Fork 出来的项目更新最新的代码。 实施网上找了一圈，发现有两种方案，一种是采用命令行形式，一种是直接在 Github 上操作，因为我们内部采用的不是 Github，也不是 OSChina 的 Git，于是只有第一种可以使用。 Git 命令行操作提示：跟上游仓库同步代码之前，必须配置过 remote，指向上游仓库 。 从命令行窗口切换到当前项目下 配置远程仓库，指向它 拉取上游仓库更新 切换本地仓库到 master 或者你要更新的分支 通过 merge 命令从 upstream/master 分支合并代码 提交并推送合并后的代码 下面是关于命令行的操作： 123456789101112131415161718192021222324252627# ORIGINAL_OWNER 仓库的拥有者# ORIGINAL_REPOSITORY 仓库的 Git 地址# 自行替换git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.gitgit fetch upstream# remote: Counting objects: 75, done.# remote: Compressing objects: 100% (53/53), done.# remote: Total 62 (delta 27), reused 44 (delta 9)# Unpacking objects: 100% (62/62), done.# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY# * [new branch] master -&gt; upstream/master git checkout master# Switched to branch 'master'git merge upstream/master# Updating a422352..5fdff0f# Fast-forward# README | 9 -------# README.md | 7 ++++++# 2 files changed, 7 insertions(+), 9 deletions(-)# delete mode 100644 README# create mode 100644 README.mdgit commit -am "merge from branch upstream/master ... "git push Github 操作因为这一块自己也没有动手实践，于是从参考的 Blog 那边直接盗图，如果有侵权请知会。 OSChina 操作之前使用过 OSChina 的同步，貌似更简单，直接一键就能操作了。 不信你看这里： 当然这种方式还是建立在没有做任何改动上，如果有做了一些改动，还是使用命令行来操作更稳妥。 后记网上其实方便就能搜索到答案了，但是一些命令用的少的话，经常会忘记，而重新搜索的话会耗费不少时间，而只记录 URL 的话又不能加深印象，于是才有本文的存在。 参考如何同步 Github fork 出来的分支]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Fork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 Android 上抓包（Socket 包）]]></title>
    <url>%2F2017%2F08%2F03%2Fhow-to-packet-capture-in-android%2F</url>
    <content type="text"><![CDATA[背景在实际使用过程中遇到需要抓取移动设备的 socket 包，之前一直是采用 Charles 抓取 http/https 包，对 socket 的需求没有那么强烈，但是终究还是遇到了，于是记录一下抓取过程，后面方便自己查看。（实际上从遇到动手实施之后到写下博客，我已经忘了怎么实现的了，脑子不好，掩面逃走） 要求Android 已 root 设备一台 tcpdump 工具一枚 Wireshark 工具一枚 实现把 tcpdump 上传到手机上12345adb push tcpdump /sdcard/data # 上传 tcpdumpadb shell # 登陆 adb shellsu # 提权为 rootcp /sdcard/data/tcpdump /data/local/ # 将 tcpdump 拷贝到 /data/local 目录下chmod 777 /data/local/tcpdump # 修改 tcpdump 执行权限 运行 tcpdump12# 将抓到的包输出到 netCapture.pcap 文件中/data/local/tcpdump -i any -p -s 0 -w /sdcard/data/netCapture.pcap 参数介绍 -i: 指定监控的网络接口, any 表示监控所有端口. -p: 将网络接口设置为非“混杂”模式. -s: 指定抓取网络请求返回的大小,0 表示抓取整个网络包. -w: 指定数据包写入文件的位置. 更多关于 tcpdump 的介绍可以查看这里 导出 netCapture.pcap 到 PC 上1adb pull /sdcard/data/netCapture.pcap ./ 使用 Wireshark 查看包在 Mac 下直接双击 netCapture.pcap 文件就可以了。 如图： 因为笔者是为了找客户端发出去的包，所以在筛选条件加入 ip.dst == 192.168.77.55 ，如果想查看收到的包可以加上这个，即 ip.dst == 192.168.77.55 or ip.src == 192.168.77.55 ，然后查找到对应的 [PSH, ACK] 开头的包就能找到客户端有发送出去的包了。 三次握手四次分手 TCP 协议的介绍可以看这里：通俗大白话来理解TCP协议的三次握手和四次分手 后记了解一些关于抓包的技巧对于定位网络问题还是有一定帮助的，特别是用于理解底层协议也有帮助，通过这个也可以清楚的看到收到什么，发出去什么，这个是没办法骗你的。 希望对你有帮助，祝生活愉快！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Socket</tag>
        <tag>packet capture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何反编译 APK 包和重打包]]></title>
    <url>%2F2017%2F08%2F03%2Fhow-to-decompile-and-repack-apk%2F</url>
    <content type="text"><![CDATA[背景因为找不到原来的版本节点了，现在只有一个 APK 包，包有点久了，难以追溯了，于是只能把包拆开再重新打包一下了。 那么问题来，虽然以前有研究过一阵子反编译，不过年代久远了，都忘记是什么回事了，只能去找找原来的代码回来温习一下。 依赖反编译需要涉及的工具有: apkTool.jar（单独下载链接）重打包需要涉及的工具有: 签名文件（自备签名），jarsigner（JDK 集成），zipalign（Android SDK 集成） 反编译只要准备好了 apktool 了之后，反编译其实就是一条命令行的问题就好了，看这里 1java -jar apktool.jar d -f -s &#123;apk_name&#125; -o &#123;output_folder&#125; 重打包重新打包需要自行准备好签名文件，那么需要经过这几个流程： 重打包 重签名 对齐 APK 重打包1java -jar apktool.jar b &#123;org_apk_folder&#125; -o &#123;output_apk_file&#125; 重签名1jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore &#123;keystore&#125; -storepass &#123;storepass&#125; -signedjar &#123;signed_unalignedjar&#125; &#123;unsign_apk&#125; &#123;alianame&#125; 对齐1zipalign -v 4 &#123;signed_unalignedjar&#125; &#123;signed_alignedjar&#125; 总结为了方便我后续继续使用，我写了两个脚本，方便自己后续可以继续使用，详细可以到 这里查看 ，惊喜不断哦。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>APK</tag>
        <tag>Decompile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 问题记录集锦]]></title>
    <url>%2F2017%2F08%2F03%2Fc-plus-plus-problems%2F</url>
    <content type="text"><![CDATA[前言重拾一下 C++ 相关知识，这里为了记录过程中遇到的问题和一些知识点，可能有些会很傻，但是留下来方便查看吧。 知识点#include &lt;xxx&gt; 和 #include &quot;xxx&quot; 的区别C++ 有一些编写好的头文件（比如标准函数库等等），它们存放在 VC++ 的 Include 文件夹里。当我们使用 #include &lt;文件名&gt; 命令时，编译器就到这个文件夹里去找对应的文件。包含 C++ 提供的头文件时，应该使用尖括号。 #include &quot;文件名&quot; 命令则是先在当前文件所在的目录搜索是否有符合的文件，如果没有再到 Include 文件夹里去找对应的文件。因此，无论这个文件是 C++ 提供的还是自己编写的，使用 #include &quot;文件名&quot; 命令一定是正确的。(推荐都用这种形式) 命名空间经常遇到这样的代码，以前没有深究为什么，现在回过头来看还是要弄清楚比较好。 12#include &lt;iostream&gt;using namespace std; C++ 标准程序库中的所有标识符都被定义于一个名为 std 的 namespace 中。所以第二行，我们就可以很好理解了。 于是我们在下文就可以愉快的使用 cin 和 cout 等等其他标准库方法了。 但是， using namespace std; 还是慎用。至少，不要在头文件里用，因为不清楚影响范围有多大，不要在任何 include 之前用。 关于命名空间的介绍：看这里 C++ 引入命名空间是为了解决编译器无法辨别 A 库中的 func 与 B 库中的 func 重名方法。它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 问题点总结期望以后这个能是一个美好的回忆。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>include</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OSX 下的 Sublime Text3 与 命令行]]></title>
    <url>%2F2017%2F07%2F25%2Fosx-use-sublime%2F</url>
    <content type="text"><![CDATA[背景笔者在 mac 下使用，有一天想着从命令行直接打开 sublime，以前都是 open ./ 然后在 finder 下把文件／文件夹拖到 sublime 上，后面发现，多走了一步，能不能减少呢？ 解决答案是可以的，于是 Google 一圈，整理了比较靠谱的解决方案。 先看看官方的介绍： osx_command_line 通过上面有两个问题： bin 找不到 默认终端可以打开，但 zsh 打不开 第一个很好解决， mkdir ~/bin ，第二个就比较麻烦了，需要在 zsh 的配置文件 ~/.zshrc 下加入相关配置才可以，汇总一下，需要操作的就是： 1234567891011mkdir ~/binln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/sublexport EDITOR='subl -w'vi ~/.zshrc# 在行末加入这几行alias subl="'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'"alias nano="subl"export EDITOR="subl"source ~/.zshrc# 重新打开 iTerm 就可以了 这样你就能愉快的在终端打开 Sublime Text 了，四不四很开心，相关操作看这里： 12345678910111213141516171819$ subl --helpUsage: subl [arguments] [files] 编辑指定的文件 edit the given files or: subl [arguments] [directories] 打开指定的目录 or: subl [arguments] - 编辑 stdinArguments: --project &lt;project&gt;: 载入指定的 project --command &lt;command&gt;: 运行指定的命令 -n or --new-window: 打开一个新的窗口 -a or --add: 添加文件夹到当前窗口 -w or --wait: 返回前等待文件关闭 -b or --background: 不激活该应用程序 -s or --stay: 文件关闭后保持应用程序激活状态 -h or --help: 显示帮助并退出 -v or --version: 显示版本信息并退出如果从标准输入 --wait 是隐式的。 使用 --stay 当文件关闭是不切换到后台控制台(只与是否有等待的文件有关)。文件名可以通过加 :line 或者 :line:column 后缀来指定打开的定位。 Sublime Text 下打开命令行能够从命令行下打开，那么也就能从 Sublime Text 下打开命令行咯。 没错，我也觉得是这样的，网上找了一圈，有个东西完美解决，这里也介绍一下。 安装插件 Termineralcommand + shift + p，输入 pip，打开 Package Control:Install Package，等会弹框出来找到 Termineral， 点击安装 安装完成之后需要配置一下， 打开 Sublime Text -&gt; Preferences -&gt; Package Setting -&gt; Termineral -&gt; Settings-User 在下面加入配置： 12345&#123; // The command to execute for the terminal, leave blank for the OS default // See https://github.com/wbond/sublime_terminal#examples for examples "terminal": "iTerm2-v3.sh"&#125; 这里我是用的是 iTerm2，如果是 iTerm 的话，&quot;terminal&quot;: &quot;iTerm.sh&quot; ，如果是默认终端， &quot;terminal&quot;: &quot;Terminal.sh&quot;。 如何使用我们可以参考这里的快捷键配置： Sublime Text -&gt; Preferences -&gt; Package Setting -&gt; Termineral -&gt; Key Bindings-Default 1234[ &#123; "keys": ["super+shift+t"], "command": "open_terminal" &#125;, &#123; "keys": ["super+shift+alt+t"], "command": "open_terminal_project_folder" &#125;] 这样你就能愉快的在 Sublime Text 下打开终端了，四不四很兴奋！ 参考 如何在 mac 中用命令行时用 sublime 打开文件 Setup Terminal for Sublime Shorcut “subl” sublime_terminal]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
        <tag>skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3 的自我修养]]></title>
    <url>%2F2017%2F07%2F25%2Fsublime-skill-guide-for-game-devloper%2F</url>
    <content type="text"><![CDATA[介绍插件安装与使用我的插件与使用方法命令行使用笔者在 mac 下使用，有一天想着从命令行直接打开 sublime，以前都是 open ./ 然后在 finer 下把文件／文件夹拖到 sublime 上，后面发现，多走了一步，能不能减少呢？ 可以的，于是 Google 一圈，比较靠谱的解决方案是： 官方的介绍是这个： osx_command_line 通过上面有两个问题： bin 找不到 默认终端可以打开，但 zsh 打不开 第一个很好解决， mkdir ~/bin ，第二个就比较麻烦了，需要在 zsh 的配置文件 ~/.zshrc 下加入相关配置才可以，汇总一下，需要操作的就是： 1234567891011mkdir ~/binln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/sublexport EDITOR='subl -w'vi ~/.zshrc# 在行末加入这几行alias subl="'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'"alias nano="subl"export EDITOR="subl"source ~/.zshrc# 重新打开 iTerm 就可以了 这样你就能愉快的在终端打开 sublime 了，四不四很开心，相关操作看这里： 12345678910111213141516171819$ subl --helpUsage: subl [arguments] [files] 编辑指定的文件 edit the given files or: subl [arguments] [directories] 打开指定的目录 or: subl [arguments] - 编辑 stdinArguments: --project &lt;project&gt;: 载入指定的 project --command &lt;command&gt;: 运行指定的命令 -n or --new-window: 打开一个新的窗口 -a or --add: 添加文件夹到当前窗口 -w or --wait: 返回前等待文件关闭 -b or --background: 不激活该应用程序 -s or --stay: 文件关闭后保持应用程序激活状态 -h or --help: 显示帮助并退出 -v or --version: 显示版本信息并退出如果从标准输入 --wait 是隐式的。 使用 --stay 当文件关闭是不切换到后台控制台(只与是否有等待的文件有关)。文件名可以通过加 :line 或者 :line:column 后缀来指定打开的定位。 参考 如何在 mac 中用命令行时用 sublime 打开文件 Setup Terminal for Sublime Shorcut “subl”]]></content>
      <categories>
        <category>Skill</category>
      </categories>
      <tags>
        <tag>skill</tag>
        <tag>sublime text3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git tag 操作]]></title>
    <url>%2F2017%2F07%2F25%2Fhow-to-action-tag%2F</url>
    <content type="text"><![CDATA[背景原谅我对 tag 的操作还是很陌生，之前打的 tag 也是各种乱七八糟，为了详细的了解一下 tag 操作，决定用一篇博客来详细阐述一下。 比较系统的介绍看这里： 2.6 Git 基础 - 打标签 操作在 sourceTree 上操作的时候，发现明明我已经删除 tag 了，但是还是没有正确的删除 tag，这就让我很纳闷了。之前因为懒，没有认真对待，但是后面发现，项目跑的久了，不系统的梳理一下标签会很混乱。 图形操作不行，咱就用命令行呗。 查看标签我们在标签那一栏看到的其实是通过这个命令来获取的： 1git tag 当然可以使用这个来过滤一下，如果 tag 较多的话，过滤前缀为 v1.0. 的 tag 1git tag -l 'v1.0.*' 删除标签删除本地 tag: 1git tag -d v1.0 只删除本地的没有用，下次 fetch 的时候还会拉下来，再删除远程仓库中的 tag ，跟删除远程分支的语法类似 1git push origin :refs/tags/v1.0 添加标签Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。 一般我们都建议使用含附注型的标签，有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，存储的一个独立对象，两者的操作如下： 含附注的 tag 123# -a 取 annotated 的首字母# -m 标签说明git tag -a v1.0 -m 'my version 1.0' 轻量级的 tag 1git tag v1.0 查看标签 1git show v1.0 补充标签有时候我们发布版本的时候，然后忘记给添加标签，肯定也是可以继续补上的，提交的时候记得附上文件的校验和即可，查看校验和使用 git log ，所以对应的命令应该是： 12# 9fceb02 为你某次提交的校验和git tag -a v0.8 9fceb02 -m 'my version 0.8' 签署标签和验证标签这两个个人暂时不会用到，所以就不讲了，可以从这里出门查看： 签署标签 ， 验证标签 推送标签所有的操作如果没有使用 push 那么都是在本地修改而已，可以使用 git push origin [tagname] 进行推送，如果一次操作的 tag 较多，可以使用 git push origin --tags 推送多个。 最后写完这个之后，我也受益良多，以前一直觉得标签貌似就是一个标记而已，但实际操作起来还是有不少要注意的，看完希望可以帮到你！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草拟读书计划]]></title>
    <url>%2F2017%2F07%2F21%2Fthe-plan-to-read-a-book%2F</url>
    <content type="text"><![CDATA[前言一年读的书已经少的可怜了，可是每次读完感受颇深，然后就随着记忆曲线慢慢消散风中，为了改变这个状态，特地给自己草拟了一个针对读一本书的计划，立下 Blog 以督促自己，希望这次可以成。 图片来源：Google Search，侵删 翠花上菜我把计划分成一下几个部分，各位看官且继续看下去。 主题 时间 现状 目标 实施方案 实施计划 任务安排 关键节点 结果输出 是不是看起来有组织、有计划、有目标、有文化了，分分钟可以当项目管理经理了。 《游戏编程模式》笔记本次以最近想读的《游戏编程模式》为例子。 主题阅读《游戏编程模式》，汇总读书笔记，总结高效游戏设计的奇技淫巧，从而提高游戏编程技巧 时间 阅读：45h 总结：45h 截止时间： 2017-9-10（合计 1 个月 20 天） 现状 在进行项目重构时，经常遇到思维盲区，感觉无从下手，又这样改也是可以？ 使用设计模式的时候，偏爱单例模式，然后想不起用其他什么模式好？ 如何设计才能让代码具有良好的扩展性，同时又灵活高效呢？ 带着这样的问题，来阅读本书，期望得到解答。 目标给代码做减法，合理的运用设计模式，设计高扩展，灵活高效的工程代码整理笔记采用 gitbook，掌握流行的书籍输出工具 实施方案实施计划 下载／购买书籍，在线阅读地址： Game_Programming_patterns 阅读书籍并写读书笔记 一周一个周期，记录阅读心得 整理笔记汇总成文档 在项目中找出设计不合理的代码 分享整个收获 任务安排 掌握 Gitbook 的操作方式 每周汇总读书笔记并记录到 Blog 上 读书结束之后回溯代码，找出不合理的代码 在组内开展分享 关键节点 8 月 20 日完成阅读 9 月 1 日完成整理问题代码 9 月 10 日组织分享会议 结果输出 一个读书笔记 一些问题代码（文档整理输出） 一份关于「如何使用 Gitbook 教程」 一份分享文档 一次分享会议 总结做这样一件事情，有感于之前在公司做性能优化时，因为一下子「自由」起来，可以给自己安排活了，然后就使劲安排，总是规划的满满的，但容易遗漏很多东西，导致测试 Bug 多，效果不明显。 后面阶段性总结，发现做什么都要有计划，有目标，那么事容易成。而计划就要涵盖你的目标，安排，成果，让自己看起来更明确，于是我把这个记录下来。 图片来源：Google Search，侵删]]></content>
      <categories>
        <category>Reading</category>
      </categories>
      <tags>
        <tag>Read</tag>
        <tag>Plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Python 批量调整图片大小]]></title>
    <url>%2F2017%2F07%2F13%2Fuse-python-to-resize-images%2F</url>
    <content type="text"><![CDATA[前言之前拿到表情图片的时候发现给的尺寸都偏大，而实际使用又不需要那么大，如果人工一个个去改，感觉要累死的节奏，正好用 Python 玩的有点上火，于是就去找了一下，发现 Python 下有一个 Pillow 图片库可以很方便的处理，于是就有了下面的一个脚本。 Python 有毒，请慎用！ 使用注意： 需要手动安装 Pillow 库，具体可以 Google 之 。 Mac 下可以直接使用：123# Pillow 依赖于 multiprocessingsudo pip install multiprocessingsudo pip install Pillow 下面是具体的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python# coding:utf8# 使用 Image 修改宽高# usage: python resizePic.py# the file or filePath: /Users/amnon/Documents/test.png# the width you want: 120# the height you want: 120import osfrom PIL import Image# 返回指定目录的所有文件（包含子目录的文件）def get_all_pic(floder_path): file_list = [] if floder_path is None: raise Exception("floder_path is None") for dirpath, dirnames, filenames in os.walk(floder_path): for name in filenames: file_list.append(dirpath + os.sep() + name) return file_listdef resize_all_pic(file_list, width, height): size = 0 for pic in file_list: img = Image.open(pic) w,h = img.size new_img = img.resize((int(width),int(height)),Image.ANTIALIAS) new_img.save(pic,quality=100)def main(): filePath = raw_input("the file or filePath: ") width = raw_input("the width you want: ") height = raw_input("the height you want: ") file_list = [] if os.path.isfile(filePath): file_list = [filePath] else: file_list = get_all_pic(filePath) resize_all_pic(file_list,width, height)if __name__ == '__main__': main() 总结使用 Python 是解放生产力的第一步，祝你在这条路上越走越远。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pilliow</tag>
        <tag>Image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 使用 sips 操作你的图片]]></title>
    <url>%2F2017%2F07%2F13%2Fuse-sips-to-resize-images%2F</url>
    <content type="text"><![CDATA[前言使用 Mac OSX 的过程中，发现需要调整图片的大小，以前在 windows 都是采用格式工厂或者 PhotoShop 等工具进行修改，当然我也用 Python 写过一个脚本，看这里。但后面发现在 Mac 下有更方便处理的方式，喜出望外。 Sips没错，这款利器就是 Spis， 拥有了它，妈妈再也不用担心我对图片进行操作了。 查看一下 sips 的 API： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556~ sips --helpsips 10.4.4 - scriptable image processing system.This tool is used to query or modify raster image files and ColorSync ICC profiles.Its functionality can also be used through the "Image Events" AppleScript suite. Usages: sips [-h, --help] sips [-H, --helpProperties] sips [image-query-functions] imagefile ... sips [profile-query-functions] profile ... sips [image modification functions] imagefile ... [--out result-file-or-dir] sips [profile modification functions] profile ... [--out result-file-or-dir] Profile query functions: -g, --getProperty key -X, --extractTag tag tagFile -v, --verify Image query functions: -g, --getProperty key -x, --extractProfile profile Profile modification functions: -s, --setProperty key value -d, --deleteProperty key --deleteTag tag --copyTag srcTag dstTag --loadTag tag tagFile --repair Image modification functions: -s, --setProperty key value -d, --deleteProperty key -e, --embedProfile profile -E, --embedProfileIfNone profile -m, --matchTo profile -M, --matchToWithIntent profile intent --deleteColorManagementProperties -r, --rotate degreesCW -f, --flip horizontal|vertical -c, --cropToHeightWidth pixelsH pixelsW -p, --padToHeightWidth pixelsH pixelsW --padColor hexcolor -z, --resampleHeightWidth pixelsH pixelsW --resampleWidth pixelsW --resampleHeight pixelsH -Z, --resampleHeightWidthMax pixelsWH -i, --addIcon -o, --optimizeColorForSharing 常用的操作12345678910111213141516171819202122232425262728# 指定宽高输出图片sips --out output.png -z $&#123;height&#125; $&#123;width&#125; input.png# 制定宽度、保持比例输出图片sips --out output.png --resampleWidth $&#123;width&#125; input.png# 指定宽度、保持比例(会覆盖源图片)sips --resampleWidth $&#123;width&#125; *.jpg# 指定宽高(会覆盖源图片)sips -z $&#123;height&#125; $&#123;width&#125; *.jpg# 顺时针旋转 90 度sips -r 90 image_file_name# 水平翻转图片 # horizontal/vertical 水平／垂直sips -f horizontal image_file_name# 修改图片格式# 使用 -s 参数可以修改图片格式为指定值，sips 支持 jpeg | tiff | png | gif | jp2 | pict | bmp | qtif | psd | sgi | tga 共 11 种格式。sips -s format jpeg input.png -o output.jpg# 获取图片 meta 信息sips -g pixelWidth -g pixelHeight image_file_name# 可使用查看更多man sips 总结有了 sips 祝你在图片操作上越走越远。]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>skill</tag>
        <tag>Mac</tag>
        <tag>sips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何成为一名合格的游戏程序员]]></title>
    <url>%2F2017%2F07%2F11%2Fhow-to-be-a-game-programmer%2F</url>
    <content type="text"><![CDATA[游戏程序员的成长之路之前一直有关注 Milo Yip 大神，其在 2016-12-3 发布了一篇 游戏程序员的学习之路 ，作为一名游戏开发从业者，每每看到有这样的一些文章或者内容都会忍不住的看一眼，一方面是参考对照，另一方面是了解方向。 然而，看到这样的一份清单，默默的叹了口气，这是不眠不休的战斗也要好多年才能全部阅读完，阅读完然后可以掌握还不知道要多少年？难怪现在的娃娃都在开始练习编程了，果然一入 IT 深似海，从此「美女」是路人呀。 当然，看到这样一份清单，首先不能被吓到，我们是秉持「书中自有黄金屋，书中自有颜如玉」的「三好青年」，如何能放弃？这份清单是一份指南，我们要经历这么几个阶段：初级，中级，高级，资深，专家，那么以自己的身份再对应到这份清单里面去，就能明白自己该做点什么好了，作者是一名 20 几年从业经验的专家级大神，推荐的东西还是值得我们花时间去学习的。当然我还是觉得「纸上得来终觉浅，绝知此事要躬行」。 程序员的成长之路在看到这份清单之前，我还见过这么一份东西，这里也列出来，希望对你有帮助。 How to be a programmer?，这个的范围比上面的更广阔一点，内容来讲相对比较基础一点。 令人惊叹的学习之旅在 GitHub 这个伟大的社区，我发现有这么一系列的东西，对于我们深入了解提供了一个索引，本着我知道，你也应该知道的原则，请从这里去。Awesome 我果然爱学习，关注的东西还是不少？ 图片来源于网络，侵删 如何实施好了收一收。 我认为，除了知道有这么一些东西，还是需要从自身出发。 我给自己的定位是棋牌行业的前端游戏开发从业者，那么在这么一个比较窄的面里，该学该知道的东西范围就少很多了。 把这个定位拆分开来： 行业：棋牌 职务：前端游戏开发 关于编程能力的，我觉得可以从这几方面划分： 语言 Lua Java(Kotlin) + Groovy ObjectC C/C++ Python（做一些工具） Shell 工具 Sublime text Visual Studio + BabeLua Android Studio Xcode Visual Studio Code BabeUIEditor BabeSwf TexturePacket AdrenoProfiler 引擎能力 开发环境 基础概念 图像渲染和动画 数据结构 声音 内存管理 人机交互 网络 数据存储 数据解析 第三方集成 发布 图形学 OpenGL／Direct Shader 网络 TCP/UDP Socket/Http 软件开发 设计模式 敏捷开发 重构 业务能力 棋牌的核心功能 基础模块（登录，大厅，个人信息，排行榜，消息中心，商城，好友） 图片来源于网络，侵删 除了编程能力，个人认为还要掌握的有：行业的相关资讯获取途径，分析游戏盈利与否的能力，最最重要的还在沟通。虽然我们跟机器打交道比较多，但是还是需要同人沟通。 因为还没思考完善，未完待补充 学习方法最近在接触和了解一种新事物的时候，我有这样一个途径，或许你可以参考一下。 如果只是简单了解一门编程语言，那么我回到这里进行检索。看我的 Blog，一个神奇的网站 2 。 如果涉及的内容挺多的，那么我会倾向于在这里找。看我的 Blog，一个有趣的网站 。当然，我觉得最主要还是先到官网查看指导手册以及 FAQ，这里才是最权威的指南，剩下的才是去其他各个地方找寻。当然这个地方隔三差五我会上来看一下， Awesome 。 问问题，请到 StackOverflow 。 学习的目的，应以可以教授别人而学习，这样掌握的更牢固，学习的更深，记住还要有文档留存哦。 总结本文作为自己的一个总结和梳理，站在自己的角度思考的问题，个人拙计，望各位大大路过海涵，或者指导一下小弟。]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>Game Programmer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Lua CJSON 无法解析单反斜杠 \ 和反斜杠加单引号 \']]></title>
    <url>%2F2017%2F07%2F10%2Ffix-lua-cjson-to-resolve-backslash%2F</url>
    <content type="text"><![CDATA[背景项目组一直用 Lua CJSON 解析 Json，效率上也比 Lua 本身的 Json 库效率高不少，解析的东西也很多，但最近遇到 &quot;\\&quot; 或者 &quot;\\\&#39;&quot; 这样符合转义规则的字符串却解析不出来，于是硬着头皮去看了 Lua CJSON 的源码，并尝试修复。 修改通过阅读源代码，我发现 Lua CJSON 解析字符串的逻辑集中在这里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void json_next_string_token(json_parse_t *json, json_token_t *token)&#123; char *escape2char = json-&gt;cfg-&gt;escape2char; char ch; /* Caller must ensure a string is next */ assert(*json-&gt;ptr == '"'); /* Skip " */ json-&gt;ptr++; /* json-&gt;tmp is the temporary strbuf used to accumulate the * decoded string value. * json-&gt;tmp is sized to handle JSON containing only a string value. */ strbuf_reset(json-&gt;tmp); while ((ch = *json-&gt;ptr) != '"') &#123; if (!ch) &#123; /* Premature end of the string */ json_set_token_error(token, json, "unexpected end of string"); return; &#125; /* Handle escapes */ if (ch == '\\') &#123; /* Fetch escape character */ ch = *(json-&gt;ptr + 1); /* Translate escape code and append to tmp string */ ch = escape2char[(unsigned char)ch]; if (ch == 'u') &#123; if (json_append_unicode_escape(json) == 0) continue; json_set_token_error(token, json, "invalid unicode escape code"); return; &#125; if (!ch) &#123; json_set_token_error(token, json, "invalid escape code"); return; &#125; /* Skip '\' */ json-&gt;ptr++; &#125; /* Append normal character or translated single character * Unicode escapes are handled above */ strbuf_append_char_unsafe(json-&gt;tmp, ch); json-&gt;ptr++; &#125; json-&gt;ptr++; /* Eat final quote (") */ strbuf_ensure_null(json-&gt;tmp); token-&gt;type = T_STRING; token-&gt;value.string = strbuf_string(json-&gt;tmp, &amp;token-&gt;string_len);&#125; 解析字符串是通过 &quot; 来标示的，然后反斜杠开头进入逻辑判断，目前 Lua CJSON 支持的几个关键转义符有：在 function json_create_config 中 123456789101112/* Lookup table for parsing escape characters */for (i = 0; i &lt; 256; i++) cfg-&gt;escape2char[i] = 0; /* String error */cfg-&gt;escape2char['"'] = '"';cfg-&gt;escape2char['\\'] = '\\';cfg-&gt;escape2char['/'] = '/';cfg-&gt;escape2char['b'] = '\b';cfg-&gt;escape2char['t'] = '\t';cfg-&gt;escape2char['n'] = '\n';cfg-&gt;escape2char['f'] = '\f';cfg-&gt;escape2char['r'] = '\r';cfg-&gt;escape2char['u'] = 'u'; /* Unicode parsing required */ 而在处理上面提到的情况的时候，因为转义符是一个特殊的字符，检测到转移符就会往下去检索下一个字符，只有符合的才会继续处理，不符合的就不继续往下处理，所以拿到的是空的。为了不对原来的改动造成大影响，我们就把原来解析出错 return 的改成原样返回。 改动如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static void json_next_string_token(json_parse_t *json, json_token_t *token)&#123; char *escape2char = json-&gt;cfg-&gt;escape2char; char ch; /* Caller must ensure a string is next */ assert(*json-&gt;ptr == '"'); /* Skip " */ json-&gt;ptr++; /* json-&gt;tmp is the temporary strbuf used to accumulate the * decoded string value. * json-&gt;tmp is sized to handle JSON containing only a string value. */ strbuf_reset(json-&gt;tmp); while ((ch = *json-&gt;ptr) != '"') &#123; if (!ch) &#123; /* Premature end of the string */ json_set_token_error(token, json, "unexpected end of string"); return; &#125; /* Handle escapes */ if (ch == '\\') &#123; /* Fetch escape character */ // modify 1 begin // 使用临时变量 tempChar 存储读取到的字符 char tempChar = *(json-&gt;ptr + 1); /* Translate escape code and append to tmp string */ tempChar = escape2char[(unsigned char)tempChar]; if (tempChar == 'u') &#123; if (json_append_unicode_escape(json) == 0) continue; json_set_token_error(token, json, "invalid unicode escape code"); return; &#125; // modify 1 end // modify 2 begin // 判断如果不在定义的列表中，指针往前走，不要返回错误 if (tempChar) &#123; ch = tempChar; json-&gt;ptr++; &#125; // modify 2 end &#125; /* Append normal character or translated single character * Unicode escapes are handled above */ strbuf_append_char_unsafe(json-&gt;tmp, ch); json-&gt;ptr++; &#125; json-&gt;ptr++; /* Eat final quote (") */ strbuf_ensure_null(json-&gt;tmp); token-&gt;type = T_STRING; token-&gt;value.string = strbuf_string(json-&gt;tmp, &amp;token-&gt;string_len);&#125; 这样 Lua CJSON 就能处理我们需要的了。 总结在使用第三方库出现问题的时候要深入内部去寻找问题，而通过修改这个也能更好的了解原理。如果你也出现类似的情况，希望可以帮到你。]]></content>
      <categories>
        <category>Bugs</category>
      </categories>
      <tags>
        <tag>Lua CJSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文案排版指北]]></title>
    <url>%2F2017%2F07%2F07%2Fchinese-copywriting-guidelines%2F</url>
    <content type="text"><![CDATA[前言浏览大知乎的时候，发现有些答主的中文排版写的很整齐，然后看看自己的，感觉看着就是那么不让人舒服？于是特意查找了一下，发现有热心的网友整理了一份 中文文案排版指北，于是特意拜读了一下，并记录下来。 注： 这里是转载的，只是特意写了一篇文章了，就把内容也补上吧。 吐槽一下，指北，指北，什么意思？同指南。特意找了一下 文献，「指北」的出现源于近几年产生的一句流行语———「找不着北」。「找不着北」本是北方方言中一句平常的生活用语,这个有意思的说法流行开来是在 1997 年。1997 年，赵强的长篇商战小说《找不着北》荣登当年全国最畅销财经小说的宝座,并被改编成 20 集电视连续剧《找不着北》。 空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间需要增加空格正确： 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 错误： 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 例外：度／百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue?Microsoft 有个 -ms-text-autospace.aspx) 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎! 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎! 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这件蛋糕只卖 1000 元。 错误： 这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点正确： 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 工具 仓库 语言 vinta/paranoid-auto-spacing JavaScript huei90/pangu.node Node.js huacnlee/auto-correct Ruby sparanoid/space-lover PHP (WordPress) nauxliu/auto-correct PHP ricoa/copywriting-correct PHP hotoo/pangu.vim Vim sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python 谁在这样做？ 网站 文案 UGC Apple 中国 Yes N/A Apple 香港 Yes N/A Apple 台湾 Yes N/A Microsoft 中国 Yes N/A Microsoft 香港 Yes N/A Microsoft 台湾 Yes N/A LeanCloud Yes N/A 知乎 Yes 部分用户达成 V2EX Yes Yes SegmentFault Yes 部分用户达成 Apple4us Yes N/A 豌豆荚 Yes N/A Ruby China Yes 标题达成 PHPHub Yes 标题达成 少数派 Yes N/A 参考文献 Guidelines for Using Capital Letters Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Corrently - wikiHow 格式 - openSUSE 全角和半角 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科]]></content>
      <categories>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>copywriting</tag>
        <tag>中文</tag>
        <tag>Chinese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目代码规范指南]]></title>
    <url>%2F2017%2F07%2F05%2Flua-code-style%2F</url>
    <content type="text"><![CDATA[格式 代码文件以 .lua 后缀结尾 代码文件保存为 utf-8 without bom 编码格式 代码缩进为 4个空格，编辑器使用tab缩进的，请修改为 tab = 4\blank* 每一行代码字符长度不超过 半个屏幕（以24寸屏为标准）。翻译文件，自动生成文件除外 代码 注释 的标准是 少而精 ，主要针对巧妙的、晦涩的、有趣的、重要的地方加以注释。所提供的注释应该是解释代码 为什么这么写 以及 这段代码的目的 文件头信息 1234-- XXX.lua 文件名-- Author: 作者-- Data: 创建时间-- Description: 作用描述 编写公共函数时（framework 目录下），提供 函数描述信息，便于以后使用 LDoc 进行文档生成，更多更详细的写法可以参考 LDoc 的文档 123456789101112131415--- XXX 简单描述-- @param XX -- 参数-- @param XX-- @return 返回值-- 举例--- foo explodes text.-- It is a specialized splitting operation on a string.-- @param text the string-- @return a table of substringsfunction foo (text)....end 命名 命名以 简洁明了 为准，具备描述性，尽可能避免缩写 命名选择优先 贴近项目，使用常见且通俗易懂的词汇术语，比如德州扑克相关术语 属性命名选名词，方法函数选动词，布尔逻辑加is 文件名，采用 大驼峰式 ，即所有单词首字母均大写，保持和代码内的类名\模块名一致，如：FileName 普通变量，命名采用 小驼峰式，即首个单词首字母小写，其他单词首字母大写，如：firstName 成员变量，命名采用 小驼峰式，加前缀 m_，如 m_firstName 类静态变量，命名采用 小驼峰式，加前缀 s_，如 s_firstName 全局变量，采用 全大写，加下划线，如 APP_ID（尽可能少用全局变量），禁止 下划线开头的全大写，如_GLOBAL，该方式为 Lua 内部使用，容易冲突 普通函数，成员方法命名采用 小驼峰式 全局函数，采用 全小写，加下划线，如 get_screen_width()（配合当前引擎） 常见i,j,k,v尽可能只用于for循环内部，_可用于占位符，表示不做处理 123456789101112for i = 1, 10 thenendfor k, v in pairs(t) thenendfor i, v in ipairs(t) thenend-- _ 标识不做处理，只用来占位，但本质上还是可以使用的变量for _, v in pairs(t) then end UIEditor 控件命名规则 123456789101112131415Image 采用 imgXxxButton 采用 btnXxxText 采用 txXxxRadioButton 采用 rbXxxRadioButtonGroup 采用 rbGroupXxxCheckBox 采用 cBoxXxxCheckBoxGroup 采用 cBoxGroupXxxTextView 采用 tvXxxEditText 采用 etTxXxxEditTextView 采用 etTvXxxView 采用 viewXxxListView 采用 lvXxxScrollerView 采用 scrViewXxxTableView 采用 tabViewXxxSlider 采用 sliderXx 1任何地方命名禁止使用 arg，该名字在旧版 lua（&lt;5.1) 中用于提供可变变量的支持（高版本 lua 在编译时可以决定是否兼容此特性）。 Lua 书写 尽可能使用 local 修饰变量；存取更快，作用域外自动释放内存，不污染全局命名空间 使用 or 做默认值实现，范式：param = param or defaultValue 1234function foo(value) value = value or &#123;&#125; ...end 单行注释用--，块注释用--[[ --]] 123456-- 后面跟一个空格-- line comment--[[ block comment--]] 字符串常用双引号&quot; &quot;，需要大量保留书写格式的文本可用[[ ]] 使用表的构造器模式来初始化表，相对减少部分 重新哈希 的消耗；（注意缩进规范） 123456789101112131415161718192021-- goodlocal t = &#123; a=1, b=1, c=1&#125;-- goodlocal t = &#123; 1,1,1,1,1 &#125;-- badlocal t =&#123;&#125;t.a = 1t.b = 1t.c = 1-- very badlocal t = &#123;&#125;for i = 1, 5 then table.insert(t, 1)end 表中插入数据，除非特殊情况，一般 少用 table.insert 123456789101112-- 常见情况不推荐使用，高层函数调用，性能受影响table.insert(t, value)-- 推荐一, 可读性与性能平衡t[#t+1] = value-- 推荐二，做大规模频繁（循环）插入时使用, 性能最好local index = 1for i = 1, 100000000 then t[index] = value index = index + 1 end 表中元素使用 , 分隔，不要用 ; 1234567891011-- goodlocal t = &#123; a = 1, b = 1&#125;-- badlocal t = &#123; a = 1; b = 1&#125; 函数创建使用 function name(...) ... end的形式 1234567891011121314-- 全局函数function global_func( )end-- 成员方法function ClassName:func( )end-- 局部函数local function func( )end 函数调用使用 :，注意函数内使用的self是不是真正的 self（禁止为 self 重新赋值） 1ClassName:func() 简短的函数可以写在一行，若写成多行，注意缩进 123456789101112131415-- goodfunction foo() return true end-- goodfunction foo() return trueend-- badfunction foo() return true end-- badfunction foo()return true end 单行执行语句的块可以写在一行，若写成多行，注意缩进 1234567--goodif not a then return b end--goodif not a then return bend 单路if判断，可转为 bool 判断，效率可读性均有提高 123456789101112131415-- badif aaa then if bbb then if ccc then if ddd then xxx end end endend-- goodif aaa and bbb and ccc and ddd then xxxend 无限循环使用 while true do ... end，不使用 repeat ... until false 除非必要，一般不用在条件表达式中与 true、false、nil 进行直接判断 123456789101112131415if exp thenendif not exp thenendif type(exp) == "boolean" and exp == true then -- 明确与true进行判断endif exp == nil then -- 明确与nil值进行判断end and 和 or 是 短路求值，意味着前面的判断通过，后面的判断表达式不会进行求值，所以不要在多层条件表达式里写逻辑 1234567if 2 &lt; 1 and 2 &lt; 3 then -- 2&lt;1判断为false，后面的 2&lt;3 不会运行endif 2 &gt; 1 or 2 &gt; 3 then -- 2&gt;1判断为true，后面的2&gt;3不会运行end 对于多级和超长逻辑判断，用括号与缩进标明层级，逻辑运算符放 行首。（当然，能简化逻辑判断最好） 12345678910-- goodif ((xxx and yyy) or (xxx and zzz)) and xxx or (yyy and zzz) then ...end-- badif ((xxx and yyy) or (xxx and zzz) and xxx) or (yyy and zzz) then ...end 变量局部化 包含已定义的全局变量比如常用 math, table 等等（大于 2 次以上的使用就认为有必要）123456789101112131415161718-- goodlocal sin = math.sinfunction localized() local x = 0 for i = 1, 100 do x = x + sin(i) end return xend-- badfunction nonlocal() local x = 0 for i = 1, 100 do x = x + math.sin(i) end return xend 长字符串的拼接建议采用 table 才处理 1234567891011121314-- goodlocal s = ''local t = &#123;&#125;for i = 1,300000 do t[#t + 1] = 'a'ends = table.concat( t, '')-- badlocal s = ''local t = &#123;&#125;for i = 1,300000 do s = s .. 'a'end Lua 行尾不建议加上分号，保持 Lua 本身的规范 项目规范 UI编辑器设置生成 lua 文件路径为 Resource/scripts/app/layout 项目内方法 分类命名 12345点击事件：onXXXClick();网络请求：requestXXX();网络响应：onXXXresponse();原生回调：onNativeXXX();消息回调：onEventXXX(); 文件 require 其他模块顺序是 engine-&gt;framework-&gt;app，最后引用同目录模块 1234require("engine/xxx/xxx")require("framework/xxx/xxx/xxx")require("app/base/xxx")require("app/xxx") 消息定义统一到 eventCommand.lua 文件中，不在直接定义于模块内 针对需要立即使用的模块在 文件头 require 进来，其他的可放在 runInNextFrame 中延迟加载 对引擎模块的扩展不能直接在引擎层（ engine 目录下）修改，需要写到 framework 目录下 外部访问某模块内的成员变量需使用 getXXX，setXXX，不能直接访问。可使用全局 addProperty 函数简化代码实现 编辑器以及其他工具生成的配置文件（布局文件，拼图文件）需返回由 local 修饰的表 针对网络回调中过多的数据传递，可使用 table 包裹参数，避免方法定义过长，控制参数的数量 函数内使用的数据尽可能通过参数传递进来，而不是直接访问成员变量/全局变量；提高函数本身的模块性 项目内存在多个数据类用于模块间共享数据，新增数据需要分清属性放于正确文件中 123456globalInfo.lua -- 整个游戏共享accountInfo.lua -- 账号相关数据，切换账号，数据失效roomInfo.lua -- 房间相关数据， 切换房间，数据失效clientConfig.lua -- 客户端相关配置常量serverConfig.lua -- 服务器相关配置常量 不要随意使用 magic number，有意义的数字需要用变量/常量定义，至少也要在旁边加上注释 布局文件名，应与场景文件名一致最后加 UI 进行区分，如某弹窗名称为：FileNamePop，对应布局文件名称应为：FileNamePopUI 翻译需要注意一下几点： 123456789101112131415161718192021222324252627282930311)翻译中出现多个%s加上序号。(原因：多语言翻译有时顺序可能会有改变) 举例： -- bad "%s對%s優雅的拋了個真心玫瑰"; -- good "#s1對#s2優雅的拋了個真心玫瑰"; 2)涉及到日期的文字，%s 也需要加上序号，并于翻译文字后面加上实例注释。(原因，多语言日期顺序与中文不一样) -- bad "%s月%s日%s:%s" -- good "#s1月#s2日#s3:#s4"; -- 12月1日 12:00 3)避免出现这样一句话拆分的翻译，这样翻译完全无法翻译了，改为一整句. --bad str_report_msg1 = "現在比賽" str_report_msg2 = "分鐘，還剩" str_report_msg3 = "名選手，您現在是第" str_report_msg4 = "名。" --good 現在比賽#s1分鐘，還剩#s2名選手，您現在是第#s3名。 4)涉及到比赛，排行榜等含有名次的翻译，需要考虑到多语言中名次非纯数字，如：1st，2nd，3rd，4th --bad "恭喜您获得本场比赛%d名" -- 不适配字符串 --good "恭喜您获得本场比赛%s名" -- 适配字符串 XxxManager 作为成员变量时，命名统一为 m_xxxManager 的形式( m_manager 全名，首字母小写)，方便追踪代码。 Git 提交信息注明类型： feat：新功能（feature） fix：修补 bug docs：文档（ documentation ） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 cr：code review 修改]]></content>
      <categories>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>code style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Code Review 指南]]></title>
    <url>%2F2017%2F07%2F05%2Fcode-review-guide%2F</url>
    <content type="text"><![CDATA[Code Review 的目的看看 Wiki 百科怎么说吧，维基百科：代码审查 总结起来，有这么几个方面： 传播知识 让其它并不熟悉代码的人知道作者的意图和想法，从而在以后轻松维护代码。 促使大家相互学习对方的长处和优点。 增进代码质量 让你的代码可以更好的组织起来，更容易阅读，具有更高的可维护性。 找出潜在的 bug 顺便进行的意外收获。 不应该出现的： 检查代码风格和编程规范 当前初始时期的附加责任而已，代码符合规范属于每个人自己的事情 规范遵守看这里：项目代码规范指南 检查常规的 bad smell 和代码 Bug 应该依赖于 IDE 和静态代码检查工具 Code Review 的执行 commit 代码时，分功能提交。 不要吝啬你的评价，Code Review 是一个互相学习的过程。 及时 review 代码，确保当天的 review 任务当天完成。 认真 review 代码，为你花费的时间负责，宁可不 review 也不可草率 review 。 功能开发 Code Review 策略 新功能开发，需进行内部技术评审，制定功能技术方案。 新功能开发，reviewer 为参与技术评审的开发全程 review 开发人员代码。 review 回归 在新的提交信息里面注明回归的 review ID，目前 review id 模板为 TXSNS-CR-XX，这样该次提交将直接并入前次 review，不会产生新的 review。 Code Review 策略 每次提交随机指定 2 名 reviewer 和 1 名 watcher 。 每周整理输出未经过 review 的 commit 。 Code Review 工具 使用 upsource 构建后台，让我们轻松愉快的 Code Review 地址：http://192.168.97.2:40001 Upsource 能为代码审查提供哪些便利 对多种类型的代码库与软件开发语言进行代码浏览 对同一个代码库的多个修订版本进行浏览，并且通过一个图形化工具显示多个修订版本之间的关系 对代码变更进行跟踪，包括提交历史、变更差异比较，以及分支与合并的操作 对团队的代码进行审查，包括代码的讨论、跟踪代码评论以及最终的结论 如何进行代码审查 当开发者 A 提交完代码之后，项目管理员 B 登录到 Upsource ，可以看到所有项目的索引，每个项目都有对应一个特定的 VCS 仓库。 单击项目名称列出每一次提交的版本，每一次提交的代码罗列，这里你可以浏览代码，创建代码审核，分支列表，分支与分支代码比较，代码提交代码审核分析（可视化图表）……等等你想要的功能。 拖动滚动条，将光标移动到需要进行审核的修订版本上，点击 Create review 创建一次新的代码审查 代码对比 点击左边修订版中提交的文件名显示嵌入差异： 点击Side-by-side diff可以查看整个文件在提交前后的变化 关于代码评论无论你是作为一个 author 、 reviewer 或 watcher ，你都可以发表评论，发表的评论所有参与的人都可以看得见 有三种类型的评论： 审查意见：这种类型的评论是不是捆绑到任何代码特定文件或部分。 行级评论：这种类型的注释与特定的代码行相关联。 代码块评论：这种类型的评论是为了找出一个特定的代码片段中的一个文件进行审查。 行级评论 代码块评论 评论一下： 参与评论B 进行评论后，开发者 A 会收到邮件通知，登录 A 账户，可以清晰的看到 B 的评论的代码，可以进行回复 当点击 Accept 时，表示接受此次修订，此次审查被视为完成。 Upsource 分析功能Upsource 提供了例如代码提交分析、代码审查分析等功能。 这些方便我们后期进行统计和分析。 关于 review 之后的代码改动每次 review 有一个 ID，对应的人在针对修改意见提交修改的时候，可以在提交记录中把 ID 带上， Upsource 会根据 ID 自动合并你的提交原来那个 ID 那里，这样不会出现多余的 review 记录。 总结Upsource 是一款简单易用，社交属性强的 code review 工具，我想，大家会越来越爱上 Code Review 。以后见面不问其他就问，今天你 Review 了么？]]></content>
      <categories>
        <category>Docs</category>
      </categories>
      <tags>
        <tag>code review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何正确拉取 Git 更新]]></title>
    <url>%2F2017%2F06%2F30%2Fhow-to-pull-the-remote-commit%2F</url>
    <content type="text"><![CDATA[问题来源从 SVN 切换过来的都是习惯 SVN update，然后 commit 就好了，但是切换到 Git 之后，发现我想更新都不可以，这是什么事？ Git 不同于 SVN 就在于你操作的本地文件（版本控制中）有修改，那么你需要对他进行安置（操作）才可以更新，不像 SVN 每次直接 update 再 commit 就好了，Git 需要 action 本地再进行 update，所以每次都很懵逼，但是一旦你习惯了，其实也没那么复杂，无非就是手法不一致而已。 操作在操作之前，建议先获取(fetch)一下更新，查看最新的状态再进行操作。 本地提交法如图： C2 是我们当前的节点， C4 是我们本地修改并提交的，这个时候， develop 分支上有一个新的更新，我们想拉取下来。 变基／衍合（rebase）【 recommend 】采用这种形式的话，我们可以保持主线的单一性，线条看起来更好看，操作之后会变成这样。 操作： 如果确实要修改，推送上去就可以了。 注： rebase 发生在我们本地有未推送的情况下，操作过程中如果有冲突，我们要先解决完冲突然后再继续 rebase 就好了。 合并（pull） 采用这种方式的话，我们的 develop 会显示一个合并节点，当然这种也没有什么错，只是太多的合并，看起来不是特别美观，所以还是用上面的方式吧。 操作： 暂存大法除了上面的需要提交的方式，有时候我们不想提交自己的代码，那么这个方式适合你。利用 暂存，让你的代码存储在另外一个空间，这样就可以拉取更新然后再应用贮藏回来就可以了。 记住这个按钮，你会喜欢上他的。 注：暂存只会存有版本控制的文件，新增且未加入的不会 子模块更新因为我们项目添加了一个子模块，所以更新的时候优先到子模块更新，然后再到主项目下更新。有的小伙伴现在主项目更新，结果子模块被强制设到索引去了，导致代码丢失，这个就很悲剧了。 总结好了，今天的 Git 小课程结束，希望有对你产生帮助。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇的网站（2）]]></title>
    <url>%2F2017%2F06%2F30%2Fan-interesting-website-2%2F</url>
    <content type="text"><![CDATA[前言最近觉得有必要扩展自己对其他编程语言的了解，然后可以做一个简单的入门，以前都是直接网上搜索官方教程，但官方教程有一个问题，就是短时间内难以掌握，这样我想短时间内了解这门语言的语法就变的不可能，后面在一些链接里面找到这么一个网站，觉得很切合我的需求，于是决定写个文章分享一下，也证明确实有其他人跟我有一样的想法。（关于说吃快餐难以掌握语言精髓的这里不谈） 介绍网站截图： 网站主要分成三个模块： 算法和数据结构 语言 包含 80+ 种，基本上你见到的语言都在这里了 工具 包含 16 个工具型语言 总结善用工具，让自己更快更省。 图片来源：Google Search，侵删]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>website</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何撤销远程 Git 修改]]></title>
    <url>%2F2017%2F06%2F28%2Fhow-to-reset-the-remote-commit%2F</url>
    <content type="text"><![CDATA[前言项目开始推 Git 作为代码管理，然后因为其他同事不是特别了解 Git 的操作流程，特别是在 GitFlow 工作流程下，更容易出现误操作，比如直接在 master 上提交更新，合并出错等等。 删除远程提交操作这种强制撤销远程 Git 提交理论上是不推荐使用的，比较推荐提交回滚，所以 sourceTree 上没找到对应的操作方法，但是强迫症受不了，于是找了一下，行之有效的方法。 假设最近你的提交有： commit 3 commit 2 commit 1 其中最后一次提交 commit 3 是错误的，可以执行 1git reset --hard HEAD~1 此时, HEAD is now at commit 2, 然后再使用 1git push --force 将本次变更强行推送至服务器。这样在服务器上的最后一次错误提交也彻底消失了。 注意： 这类操作比较比较危险，例如：在你的 commit 3 之后别人又提交了新的 commit 4， 那在你强制推送之后，那位对应的 commit 4 也跟着一起消失了。 撤销本地修改撤销本地修改，不会向撤销远程那么复杂， Git 提供三种方式重置，分别是： hard 强制清除本地改动 soft 保存本地改动，不重置索引 mixed 撤销提交，重置索引，本地修改保存 当然我们想要的就是不留痕迹，所以，跟上面的一样，最新一次提交不要了，这么操作 1git reset --hard HEAD~1 注意： 操作有风险，请谨慎操作 撤销合并假设我们出现如图这种情况： 这种情况是我们项目完成 release 版本发布了，然后发现，坑爹的，还有代码没有提交，需要撤销一下我们的操作。注意： 此时的 release/1.0.0 这个分支还存在，如果已经删除了，不好意思，还是别做额外的操作了，麻烦。 好了，要撤销分支的提交的话，需要这么操作： 12345678git checkout mastergit reset --hard HEAD~1git push --forcegit checkout developgit reset --hard HEAD~1git push --forcegit tag -d 1.0.0git push origin :refs/tags/1.0.0 这个时候，我们的提交就变成这样了： 下面就继续做你的改动吧，然后再提交就可以了。 原理同上面操作是一致的，需要分别在对应的分支上重置会上一个状态。 如果有其他关于撤销分支的内容可以参考这里： undoing-merges 注意：操作不可逆，请谨慎操作，重置的时候记得切换到对应的分支上操作。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个有趣的网站]]></title>
    <url>%2F2017%2F06%2F20%2Fan-interesting-website%2F</url>
    <content type="text"><![CDATA[前言闲来无事逛逛 Github 趋势，发现这么一个仓库，按图索骥，打开一看 learn-anything。好家伙，怎么知道我喜欢学习，想要学习呢？ 介绍话不多说，直接上图： 涉及的内容有： Github 上的介绍大家可以看看。 我觉得还是很有趣的，推荐给大家瞧瞧看看，收藏起来，玩弄一下，不敢私藏，特发博文分享一下，祝大家也有所收获！ 后续吐槽：现在的 JavaScript 和 Python 如日中天呀，基本上都是他们在发布新内容，想想自己手里头会的，惭愧。让我静静～～ 图片来源：Google Search，侵删]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>website</tag>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 之 webview 使用 tips]]></title>
    <url>%2F2017%2F06%2F16%2Fandroid-webview-tips%2F</url>
    <content type="text"><![CDATA[待加入，留个坑 ###参考： Android开发：最全面、最易懂的Webview使用详解 Android WebView 概述、捕获url、js交互、内存泄漏、缓存机制 Android：手把手教你构建 WebView 的缓存机制 &amp; 资源预加载方案 android内存优化之webview 你不知道的 Android WebView 使用漏洞]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接入 Google 支付的问题汇总]]></title>
    <url>%2F2017%2F06%2F14%2Fgoogle-play-tips%2F</url>
    <content type="text"><![CDATA[问题汇总 需要验证身份。您需要登录自己的Google账号 后端的计费点跟后台的计费点不一致 package_name + ID (recommend) 无法购买您要买的商品 VersionCode 上传的包跟本地保持一致的 Payment List 商品 ID 后端跟 Google 后台保持一致 Payment Key Google 后台的 Public_Key 保持一致 Test User 需要加入成为测试账号 此处添加 https://play.google.com/apps/testing/package_name Google Play 商店可用 Package Name 保持跟后台一致 调用 consumePurchase 出现 BILLING_RESPONSE_RESULT_ERROR 在网上找了一圈，我认为比较靠谱的解答是本地的缓存跟 Google 的不同步导致请求的时候出现超时 出现这个的时候试了很多种方法都无解，最后重新打了一个 release 包上传，隔了一晚上就正常了]]></content>
      <categories>
        <category>SDK</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>checkout</tag>
        <tag>google play</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 的不完全指南]]></title>
    <url>%2F2017%2F06%2F13%2Fgit-workflow-tutorial%2F</url>
    <content type="text"><![CDATA[Git 是什么？Git 的常用命令Git 工作流]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>workflow</tag>
        <tag>git-flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[quick-cocos2dx-2.2.6-tips]]></title>
    <url>%2F2017%2F06%2F13%2Fquick-cocos2dx-2-2-6-tips%2F</url>
    <content type="text"><![CDATA[quick2.2.6 问题记录 luasocket 不能使用方式 用下面地址的文件替换文件重新编译 替换 lib/cocos2dx/scripting/lua/lua_extensions/socket 下的 [socket_scripts.c(https://github.com/chukong/quick-cocos2d-x/blob/master/lib/cocos2d-x/scripting/lua/lua_extensions/socket/socket_scripts.c) 预编译的包 framework_precompiled.zip 有问题需要自己编译 编译方式 进入到 framework 所在目录 1compile_scripts -i framework -o framework_precompiled.zip -p framework quick 文件需要做好上面两步骤后重新编译 (笔者 xcode 8.3.3 编译的时候因为 SDK 更新了，所以无法编译) cocos2dx-3.X 以后的版本使用了 c++11 新特性 不支持 xp 如果要支持 xp 平台最后的版本为 cocos2dx 2.2.6]]></content>
      <categories>
        <category>cocos2dx</category>
      </categories>
      <tags>
        <tag>quick2.2.6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how to use BTSync(Resilio Sync)]]></title>
    <url>%2F2017%2F05%2F27%2Fhow-to-use-BTSync-Resilio-Sync%2F</url>
    <content type="text"><![CDATA[背景 笔者将自己的爱机 Mackbook Pro 下面简称（ MBP ）带到公司之后，在使用过程中，发现需要跟工作机 window 同步一些文件，采用传统方式，此处省略 1 万字 …… 物色 在网上找了一圈，最终还是决定使用 Resilio Sync 原来叫 BitTorrent Sync （虽然我以前也没听说过），网上一致好评！ 特点： 易用 跨平台 不限制大小，你的硬盘足够大就好 基于 P2P 协议，局域网内速度可观，也可以共享给局域网外的人 重点是：其他网友的资源惊喜连连 使用 下载地址：个人免费版 使用： 安装完你就知道怎么使用了，不用我多说 福利地址： BtSync Space Chang Lai 802e1fkeys 福利 后续使用了 BTSync 之后以后开车就知道往哪里去了，我们除了番号，还有 BTSync Key]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>BTSync</tag>
        <tag>Resilio</tag>
        <tag>Sync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 下搭建 Lua 环境]]></title>
    <url>%2F2017%2F05%2F27%2Fwindow-make-lua-env%2F</url>
    <content type="text"><![CDATA[首先下载 lua，解压到任意位置（路径中不要有中文） 打开 VS 的命令行工具，VS2013 x64 本机工具命令提示。输入：cd /d C:\Lua_program\Lua\lua-5.1.5\src C:\Lua_program\Lua\lua-5.1.5\src替换为你的 lua 解压路径的 src 目录 将 Lua 解压路径下的 etc 目录里的 luavs.bat 拷贝到 src 目录下 执行 bat 文件，即在第 2 步打开的命令行中输入：luavs.bat 经过批处理，生成 luac.exe, lua.exe, lua51.dll, lua51.exp, lua51.lib, 共 5 个文件，按文件夹的修改时间倒序，即可在最前排显示 在 src 同级目录下，创建 bin 目录，copy 上面的 5 个文件到 bin 目录下 配置 Lua 的环境变量 右击我的电脑，属性，环境变量， Path ，编辑，在最后一行添加你刚才创建的 bin 路径到 Path 里，记得先加个分号，在粘贴你的路径，最后再加个分号 测试 Commond + R，输入 cmd ，输入：lua -version 。即可看到 Lua 环境配置成功。]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发者证书总结 in-house]]></title>
    <url>%2F2017%2F05%2F27%2Fios-developer-certificate%2F</url>
    <content type="text"><![CDATA[更新日志 2017-07-04: 新增获取证书的教程 2017-12-20: 新增 pem 证书说明 2018-02-27: 证书过期怎么办，代码签名探析 证书类型iOS 证书分两种类型 第一种为 $99 美元的，这种账号有个人和公司的区别，公司账号能创建多个子账号，但个人的不能。这种账号可以用来上传 app store 第二种为 $299 美元的，这种账号只能用于企业内部使用，不能用来上传 app store .也就是常说的 in-house 证书（用这种证书打出来的包能在任何 iOS 设备上运行，不需要苹果的验证、签名）– 不要误解了这种账号即能上传 app store 又带有 in-house 的功能。这是两种不同的账号 开发 iOS 所需要的证书 .certSigningRequest 证书请求文件，用于生成证书文件。一般由开发者通过 Mac 机使用 KeyChain 打开「钥匙串访问」 -&gt; 「证书助理」 -&gt; 「从证书颁发机构请求证书」生成并保存在本地磁盘，以后生成的证书都使用它，唯一不可删除，删除了重新申请的就不一样了。 .cer 类型的证书 这种证书创建的时候会让你选择一个本地的私有证书上传。也是开发所必须的证书，可以根据选择绑定相应的 app IDs .p12 类似的证书 如果一个开发者账号有多个人用，那么这个证书就要从本地 Keychain Access 里把上面的 .cer 证书导出来。然后选择后缀名为 p12。 .mobileprovision 文件 创建的时候它会把开发者账号里所有的设备加进去。只有 xcode 安装了这个文件才能调试（注意。这里的 mobileprovision 如果是 distribution 那么它是不能在真机上测试的，只有上传到 app store 通过了 apple 的审核才能正常安装到 iOS 设备里面）一般来讲只要有了上面的这三种证书文件，就可以在真机上调试了。（注意 developer 类似的证书只能用于测试，distribution 证书只能用来上传 app store 没上线之前不能安装到 iOS 设备） .pem 类型证书 在使用推送证书的时候需要生成 「pem」证书给服务器，方便服务器给苹果推送服务器推送消息。生成的需要我们导出的 「p12」 证书，分别是 「key」 和 「cer」，相关的操作命令如下： 1234567openssl pkcs12 -clcerts -nokeys -out aps_development_cer.pem -in aps_development_cer.p12openssl pkcs12 -nocerts -out aps_development_key.pem -in aps_development_key.p12openssl rsa -in aps_development_key.pem -out aps_development_key.pemcat aps_development_cer.pem aps_development_key.pem &gt; aps_development.pem# test connect# openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert aps_development_cer.pem -key aps_development_key.pem 如何获得对应的证书关于不同证书的申请途径，参考： iOS证书及描述文件制作流程 iOS开发证书与配置文件的使用 证书过期了怎么办？一年一度的交公粮，之后有一些证书可能就差不多到期了，这个时候如何妥善处理证书呢？ 把之前都申请的证书重新申请一遍就好了。至于有哪些证书，可以看上面的操作流程。在后台把证书都 revoke 掉，包括开发者证书，发布证书，PP 文件，推送证书。本地「钥匙串访问」中也要删除掉「已过期的证书」。如果 CSR 过期了需要重新申请一个，不然就沿用旧的。 这里截图给大家看一下，发布一个 iOS 项目涉及到的证书有哪一些。 当中，含有 aps 的都是跟推送相关的。 代码签名探析跟证书打交道的话，难免要知道一下关于证书和签名等的来由，刚好看到这篇文章就引用过来看看，代码签名探析，原文「Inside Code Signing」，加深对 iOS 证书的理解。文章主要涉及这几个点： 证书和密匙 一个已签名应用的组成 授权机制 (Entitlements) 和配置文件 (Provisioning)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>开发者证书</tag>
        <tag>in-hourse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Sublime 的 Tips]]></title>
    <url>%2F2016%2F09%2F30%2FsublimeTips-regular%2F</url>
    <content type="text"><![CDATA[使用正则表达式 历史遗留问题，现在看到关于这种样式的 lua 代码暗不爽 1class.func = function ( self ) 想把他们替换成 1function class:func () 比较懒，一个个替换是在太麻烦了，幸好 sublime 有正则匹配，好吧。 开启正则匹配，ctrl+H 调出替换 面板，点击 左下角 ‘.*’ 所以正确的姿势是： 1234-- 用这个匹配class.(.*) = function \( self-- 用这个替换function class:$1 () 效果不错，不错为什么会有一些逗号在左边括号后面呢？ 好吧，再来： 1234-- 用这个匹配class.(.*) = function \( self,-- 用这个替换function class:$1 () 嗯，替换效果还不错。 不过这样要匹配两次，作为程序员，不允许呀。得想想办法 12(.*)\.(.*) = function(\s?)\((\s?)self(,?\s?)(.*)(\s?)\)function $1:$2 ($6) 相关说明： \s 匹配任意空格符 .* 匹配任意字符 ? 匹配0或1个 完美！ 可以睡觉了。]]></content>
      <categories>
        <category>Usage Tips</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flash android CM13 for I9300（退役的三星 S3 复活了）]]></title>
    <url>%2F2016%2F09%2F29%2Fflash-android-CM13-for-I9300%2F</url>
    <content type="text"><![CDATA[退役的三星 S3 复活了前言冷藏了一年多的三星 S3 今天心血来潮拿出来想刷一个新的系统，于是把目光瞄准了 CM ，一个口碑极好的 Android 系统提供者。首先肯定是找到我的 S3 的页面寻找对应的 ROM ，意外的发现居然支持到 CM13 了，也就是 Android 6.0 了，这让我受宠若惊，于是果断的下载 Release 版本，顺便把 Recovery 也下载了，浏览中还发现 CM14 都有了，几年前的设备居然没有被抛弃，为 CyanogenMod 点个赞，希望越来越好。PS：更多关于 WIKI 。 花絮因为太久没有刷机了，很多东西都忘记了。手贱在刷入 CM13 的时候没有把 Recovery 也一起刷进去，于是安装完各种问题接踵而来。首先我需要一个 Recovery 来为我刷入 GApps 做准备，但是如何刷入 Recovery 呢？ 网上找到的关于适用 Fastboot 刷入 Recovery 感觉很靠谱，操作也简单，于是找到这个 使用 adb fastboot 刷 CyanogenMod ROM，但最后卡在了 fastboot devices 这里，居然看不到有我的设备，那么为什么会找不到？ CyanogenMod 的官方提示是这样的。Doc: fastboot intro，可是这里没有提供好的解决方案。让我本来是“半生熟”的抓不着头脑，就想既然 CyanogenMod 的 Recovery 刷不了，那么我看看有没有其他的？转折点，于是找到了这个 TWRP，另一个提供第三方 Recovery 的，也是广受刷机者喜爱的提供者，在这里下载了对应的 TWRP，这里走了一个弯路，我不知道 CyanogenMod 的系统已经是 Root 了的，也忽略了这里说的：12sudd if=/sdcard/twrp.img of=/dev/block/mmcblk0p6 如果早点看到的话，我就已经成功了，可惜没有如果。最后也是第二天偶然看到，围魏救赵终于解决了，现在列一下正确的安装姿势。 步骤 Download Rom Download Recovery Download Google Apps(use an ARM, 6.0 zip) 建议 mini 即可 待所有下载准备就绪之后，全部放到 SDCARD 根目录下即可 进入 Recovery 模式，关机状态下长按（音量下 + Home键 + 关机键）进入。 双清 安装 Rom 即可。 其他问题 只安装了 CM13 Rom 然后安装 TMRP参考了这个How to Install TWRP 2.4 on Samsung Galaxy S3 I9300 and I9305，在新安装的 Android 系统下有一个 终端，下面操作即可。 如何通过 Fastboot 安装 Recovery ？（待解决有知道的告诉我） 系统截图]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
